(()=>{"use strict";var __webpack_modules__={89:()=>{eval("\n;// CONCATENATED MODULE: ./modules/chooseAbout.js\nconst chooseAbout = () => {\r\n\tconst chooseBlock = document.querySelector('.i5-about-choose');\r\n\tconst chooseBlockAll = document.querySelectorAll('.i5-about-choose-block');\r\n\tconst aboutContentAll = document.querySelectorAll('.i5-about-content');\r\n\r\n\tchooseBlock.addEventListener('click', (e) => {\r\n\t\tif (e.target.closest('.i5-about-choose-block')) {\r\n\t\t\tchooseBlockAll.forEach((item, index) => {\r\n\t\t\t\taboutContentAll[index].classList.add('hidden');\r\n\t\t\t\tif (item === e.target.closest('.i5-about-choose-block')) {\r\n\t\t\t\t\taboutContentAll[index].classList.toggle('hidden');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/* harmony default export */ const modules_chooseAbout = (chooseAbout);\r\n\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/common.js\nconst checkBehavior = (behavior) => {\n    return behavior === undefined || behavior === \"auto\" || behavior === \"instant\" || behavior === \"smooth\";\n};\nfunction elementScrollXY(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\nconst failedExecute = (method, object, reason = \"cannot convert to dictionary.\") => `Failed to execute '${method}' on '${object}': ${reason}`;\nconst failedExecuteInvalidEnumValue = (method, object, value) => failedExecute(method, object, `The provided value '${value}' is not a valid enum value of type ScrollBehavior.`);\n/* eslint-disable */\nconst backupMethod = (proto, method, fallback) => {\n    var _a;\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n    if (!proto[backup] && proto[method] && !((_a = proto[method]) === null || _a === void 0 ? void 0 : _a.__isPolyfill)) {\n        proto[backup] = proto[method];\n    }\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\nconst isObject = (value) => {\n    const type = typeof value;\n    return value !== null && (type === \"object\" || type === \"function\");\n};\nconst isScrollBehaviorSupported = () => \"scrollBehavior\" in window.document.documentElement.style;\nconst markPolyfill = (method) => {\n    Object.defineProperty(method, \"__isPolyfill\", { value: true });\n};\nconst modifyPrototypes = (prop, func) => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nconst scrollingElement = (element) => element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n//# sourceMappingURL=common.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scroll-step.js\nconst ease = (k) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n/* eslint-disable */\nfunction now() {\n    var _a;\n    let fn;\n    if ((_a = window.performance) === null || _a === void 0 ? void 0 : _a.now) {\n        fn = () => window.performance.now();\n    }\n    else {\n        fn = () => window.Date.now();\n    }\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\nconst DURATION = 500;\nconst step = (context) => {\n    const currentTime = now();\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n    context.method(currentX, currentY);\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n//# sourceMappingURL=scroll-step.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scroll.js\n\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value) => {\n    if (!isFinite(value)) {\n        return 0;\n    }\n    return Number(value);\n};\nconst isConnected = (node) => {\n    var _a;\n    return ((_a = node.isConnected) !== null && _a !== void 0 ? _a : (!node.ownerDocument ||\n        // eslint-disable-next-line no-bitwise\n        !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1)));\n};\nconst scrollWithOptions = (element, options, config) => {\n    var _a, _b;\n    if (!isConnected(element)) {\n        return;\n    }\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n    const targetX = nonFinite((_a = options.left) !== null && _a !== void 0 ? _a : startX);\n    const targetY = nonFinite((_b = options.top) !== null && _b !== void 0 ? _b : startY);\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n    const fallback = backupMethod(HTMLElement.prototype, \"scroll\", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element), \"scroll\", fallback).bind(element);\n    if (options.behavior !== \"smooth\") {\n        method(targetX, targetY);\n        return;\n    }\n    const removeEventListener = () => {\n        window.removeEventListener(\"wheel\", cancelScroll);\n        window.removeEventListener(\"touchmove\", cancelScroll);\n    };\n    const context = Object.assign(Object.assign({}, config), { timeStamp: now(), startX,\n        startY,\n        targetX,\n        targetY, rafId: 0, method, callback: removeEventListener });\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n    window.addEventListener(\"wheel\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener(\"touchmove\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    step(context);\n};\nconst isWindow = (obj) => obj.window === obj;\nconst createScroll = (scrollName) => (target, scrollOptions, config) => {\n    const [element, scrollType] = isWindow(target)\n        ? [scrollingElement(target.document.documentElement), \"Window\"]\n        : [target, \"Element\"];\n    const options = scrollOptions !== null && scrollOptions !== void 0 ? scrollOptions : {};\n    if (!isObject(options)) {\n        throw new TypeError(failedExecute(scrollName, scrollType));\n    }\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n    }\n    if (scrollName === \"scrollBy\") {\n        options.left = nonFinite(options.left) + element.scrollLeft;\n        options.top = nonFinite(options.top) + element.scrollTop;\n    }\n    scrollWithOptions(element, options, config);\n};\nconst scroll_scroll = /* #__PURE__ */ createScroll(\"scroll\");\nconst scrollTo = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollTo\")));\nconst scrollBy = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollBy\")));\nconst elementScroll = scroll_scroll;\nconst elementScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst elementScrollBy = (/* unused pure expression or super */ null && (scrollBy));\nconst windowScroll = (/* unused pure expression or super */ null && (scroll_scroll));\nconst windowScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst windowScrollBy = (/* unused pure expression or super */ null && (scrollBy));\n//# sourceMappingURL=scroll.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scrollIntoView.js\n/* eslint-disable no-bitwise */\n\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode) => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return 0 /* HorizontalTb */;\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return 1 /* VerticalRl */;\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return 2 /* VerticalLr */;\n        case \"sideways-rl\":\n            return 3 /* SidewaysRl */;\n        case \"sideways-lr\":\n            return 4 /* SidewaysLr */;\n    }\n    return 0 /* HorizontalTb */;\n};\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= 2 /* ReverseVertical */;\n    }\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case 0 /* HorizontalTb */:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case 1 /* VerticalRl */:\n        case 3 /* SidewaysRl */:\n            //  reverse horizontal\n            layout ^= 1 /* ReverseHorizontal */;\n            break;\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case 4 /* SidewaysLr */:\n            // reverse vertical\n            layout ^= 2 /* ReverseVertical */;\n            break;\n    }\n    return [layout, hPos, vPos];\n};\nconst isXReversed = (computedStyle) => {\n    const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n    return (layout & 1) === 1;\n};\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return 1 /* CenterAlways */;\n            case \"nearest\":\n                return 0 /* ToEdgeIfNeeded */;\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? 2 /* LeftOrTop */ : 3 /* RightOrBottom */;\n            }\n        }\n    });\n};\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n    if (align !== 0 /* ToEdgeIfNeeded */) {\n        return align;\n    }\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n        return null;\n    }\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n        return 2 /* LeftOrTop */;\n    }\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n        return 3 /* RightOrBottom */;\n    }\n    return null;\n};\nconst canOverflow = (overflow) => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\nconst getFrameElement = (element) => {\n    var _a;\n    try {\n        return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n    }\n    catch (_b) {\n        return null;\n    }\n};\nconst isScrollable = (element, computedStyle) => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element));\n    }\n    return false;\n};\nconst parentElement = (element) => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return pNode.host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n    return pElement;\n};\nconst clamp = (value, min, max) => {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n};\nconst getSupportedScrollMarginProperty = (ownerDocument) => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return [\"scroll-margin\", \"scroll-snap-margin\"].filter((property) => property in ownerDocument.documentElement.style)[0];\n};\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n    const scrollMarginValue = (edge) => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\nconst calcAlignEdge = (align, start, end) => {\n    switch (align) {\n        case 1 /* CenterAlways */:\n            return (start + end) / 2;\n        case 3 /* RightOrBottom */:\n            return end;\n        case 2 /* LeftOrTop */:\n        case 0 /* ToEdgeIfNeeded */:\n            return start;\n    }\n};\nconst getFrameViewport = (frame, frameRect) => {\n    var _a, _b, _c;\n    const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n    const [x, y, width, height] = frame === scrollingElement(frame)\n        ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight]\n        : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n    return [top, right, bottom, left];\n};\nconst computeScrollIntoView = (element, options) => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions = [];\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n    if (!ownerWindow) {\n        return actions;\n    }\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n    const writingMode = normalizeWritingMode(computedStyle.writingMode ||\n        computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n        computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n        const frameRect = frame.getBoundingClientRect();\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n        const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n    return actions;\n};\nconst scrollIntoView = (element, scrollIntoViewOptions, config) => {\n    const options = scrollIntoViewOptions || {};\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n    const actions = computeScrollIntoView(element, options);\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\nconst elementScrollIntoView = scrollIntoView;\n//# sourceMappingURL=scrollIntoView.js.map\n;// CONCATENATED MODULE: ./modules/scrollIntoView.js\n\r\n\r\nconst scrollIntoView_scrollIntoView = () => {\r\n\tconst headerMenu = document.querySelector('.header-menu');\r\n\r\n\tconst scrollUp = function (object) {\r\n\t\telementScrollIntoView(object, { behavior: 'smooth', block: 'center', inline: 'center' });\r\n\t};\r\n\r\n\theaderMenu.addEventListener('click', (e) => {\r\n\t\tif (e.target.classList.contains('header-menu-item')) {\r\n\t\t\tconst itemLink = document.getElementById(e.target.getAttribute('href').substring(1));\r\n\t\t\tscrollUp.bind(itemLink)(itemLink);\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/* harmony default export */ const modules_scrollIntoView = (scrollIntoView_scrollIntoView);\r\n\n;// CONCATENATED MODULE: ./modules/changeTheme.js\nconst changeTheme = () => {\r\n\tconst button = document.getElementById('change-theme-button');\r\n\r\n\tconst body = document.querySelector('body');\r\n\tconst header = document.querySelector('.header');\r\n\tconst headerMenuThemeButton = document.querySelector('.header-menu-theme-button');\r\n\tconst i2SkillsItemBox = document.querySelector('.i2-skills-item-box');\r\n\tconst footer = document.querySelector('.footer');\r\n\tconst item1 = document.querySelector('.i1');\r\n\tconst item2 = document.querySelector('.i2');\r\n\tconst item3 = document.querySelector('.i3');\r\n\tconst item4 = document.querySelector('.i4');\r\n\tconst item5 = document.querySelector('.i5');\r\n\tconst item6 = document.querySelector('.i6');\r\n\tconst array = [body, header, headerMenuThemeButton, i2SkillsItemBox, footer, item1, item2, item3, item4, item5, item6];\r\n\r\n\tconst toggleTheme = () => {\r\n\t\tarray.forEach((item) => {\r\n\t\t\titem.classList.toggle('dark-mode');\r\n\t\t});\r\n\t};\r\n\r\n\tbutton.addEventListener('click', () => {\r\n\t\ttoggleTheme();\r\n\t\tif (body.classList.contains('dark-mode')) {\r\n\t\t\tlocalStorage.setItem('isDarkMode', true);\r\n\t\t\tbutton.textContent = 'Светлый режим';\r\n\t\t} else {\r\n\t\t\tbutton.textContent = 'Тёмный режим';\r\n\t\t\tlocalStorage.setItem('isDarkMode', false);\r\n\t\t}\r\n\t\tisDarkMode = localStorage.getItem('isDarkMode');\r\n\t\tconsole.log('~ isDarkMode', isDarkMode);\r\n\t});\r\n\r\n\tlet isDarkMode = localStorage.getItem('isDarkMode');\r\n\tconsole.log('~ isDarkMode', isDarkMode);\r\n\r\n\tif (isDarkMode === 'true') {\r\n\t\ttoggleTheme();\r\n\t\tbutton.textContent = 'Светлый режим';\r\n\t}\r\n};\r\n\r\n/* harmony default export */ const modules_changeTheme = (changeTheme);\r\n\n;// CONCATENATED MODULE: ./modules/stickMenu.js\nconst stickMenu = () => {\r\n\tlet lastScrollTop = window.pageYOffset;\r\n\r\n\twindow.addEventListener('scroll', () => {\r\n\t\t// console.log('lastScrollTop: ', lastScrollTop);\r\n\t\t// console.log('window.pageYOffset: ', window.pageYOffset);\r\n\r\n\t\tif (window.pageYOffset < lastScrollTop) {\r\n\t\t\tconsole.log('Показываем меню');\r\n\t\t}\r\n\t\tlastScrollTop = window.pageYOffset;\r\n\t});\r\n};\r\n\r\n/* harmony default export */ const modules_stickMenu = (stickMenu);\r\n\n;// CONCATENATED MODULE: ./modules/helpers.js\nconst animate = function ({ timing, draw, duration }) {\r\n\tlet start = performance.now();\r\n\r\n\trequestAnimationFrame(function animate(time) {\r\n\t\t// timeFraction изменяется от 0 до 1\r\n\t\tlet timeFraction = (time - start) / duration;\r\n\t\tif (timeFraction > 1) timeFraction = 1;\r\n\r\n\t\t// вычисление текущего состояния анимации\r\n\t\tlet progress = timing(timeFraction);\r\n\r\n\t\tdraw(progress); // отрисовать её\r\n\r\n\t\tif (timeFraction < 1) {\r\n\t\t\trequestAnimationFrame(animate);\r\n\t\t}\r\n\t});\r\n};\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./modules/skillsAnimation.js\n\r\n\r\nconst skillsAnimation = (skillsArray, time) => {\r\n\tconst skillItems = document.querySelectorAll('.i2-skills-item');\r\n\tconst skillsBlock = document.getElementById('skills');\r\n\tlet index = 0;\r\n\tlet isSkillsAnimationShown = false;\r\n\r\n\tconst getItemText = (index) => {\r\n\t\tskillItems[index].querySelector('.skill-value').textContent = skillsArray[index].value + '%';\r\n\t\tskillItems[index].querySelector('.skill-name').textContent = skillsArray[index].skill;\r\n\t\tindex++;\r\n\t\tif (index < skillItems.length) {\r\n\t\t\tanimateItem(index, time);\r\n\t\t}\r\n\t};\r\n\tconst animateItem = (index, time) => {\r\n\t\tskillItems[index].style.opacity = '1';\r\n\t\tanimate({\r\n\t\t\tduration: time,\r\n\t\t\ttiming(timeFraction) {\r\n\t\t\t\treturn timeFraction;\r\n\t\t\t},\r\n\t\t\tdraw(progress) {\r\n\t\t\t\tskillItems[index].querySelector('.skill-name').style.width = `${progress * skillsArray[index].value}%`;\r\n\t\t\t\tif (progress >= 1) {\r\n\t\t\t\t\tgetItemText(index);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t});\r\n\t};\r\n\r\n\twindow.addEventListener('scroll', () => {\r\n\t\tconst blockY = skillsBlock.getBoundingClientRect().bottom;\r\n\t\tconst pageY = window.pageYOffset + skillsBlock.getBoundingClientRect().height;\r\n\r\n\t\tif (blockY < pageY && !isSkillsAnimationShown) {\r\n\t\t\tisSkillsAnimationShown = true;\r\n\t\t\tanimateItem(index, time);\r\n\t\t}\r\n\t});\r\n};\r\n/* harmony default export */ const modules_skillsAnimation = (skillsAnimation);\r\n\n;// CONCATENATED MODULE: ./index.js\n\r\n\r\n\r\n\r\n\r\n\r\nmodules_chooseAbout();\r\nmodules_scrollIntoView();\r\nmodules_changeTheme();\r\nmodules_stickMenu();\r\nmodules_skillsAnimation(\r\n\t[\r\n\t\t{\r\n\t\t\tskill: 'HTML & CSS',\r\n\t\t\tvalue: 50,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'JAVASCRIPT',\r\n\t\t\tvalue: 80,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'GIT',\r\n\t\t\tvalue: 40,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'WEBPACK',\r\n\t\t\tvalue: 40,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'SCSS/SASS',\r\n\t\t\tvalue: 20,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'BOOTSTRAP',\r\n\t\t\tvalue: 20,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'GULP',\r\n\t\t\tvalue: 10,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'PUG',\r\n\t\t\tvalue: 10,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'PHOTOSHOP',\r\n\t\t\tvalue: 80,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'FIGMA',\r\n\t\t\tvalue: 20,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'REACT',\r\n\t\t\tvalue: 10,\r\n\t\t},\r\n\t],\r\n\t150\r\n);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsWUFBWTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtB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VztBQUNYLGlCQUFTO0FBQ1QsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbW9kdWxlcy9jaG9vc2VBYm91dC5qcz84NzhlIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2VhbWxlc3Mtc2Nyb2xsLXBvbHlmaWxsL2xpYi9jb21tb24uanM/ODVjNiIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbC9saWIvc2Nyb2xsLXN0ZXAuanM/NzRiMCIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbC9saWIvc2Nyb2xsLmpzPzdkNjMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL3Njcm9sbEludG9WaWV3LmpzP2M0NGEiLCJ3ZWJwYWNrOi8vLy4vbW9kdWxlcy9zY3JvbGxJbnRvVmlldy5qcz80YTliIiwid2VicGFjazovLy8uL21vZHVsZXMvY2hhbmdlVGhlbWUuanM/ZTdkNiIsIndlYnBhY2s6Ly8vLi9tb2R1bGVzL3N0aWNrTWVudS5qcz9iZTljIiwid2VicGFjazovLy8uL21vZHVsZXMvaGVscGVycy5qcz80YzQwIiwid2VicGFjazovLy8uL21vZHVsZXMvc2tpbGxzQW5pbWF0aW9uLmpzPzJjNmYiLCJ3ZWJwYWNrOi8vLy4vaW5kZXguanM/NDFmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjaG9vc2VBYm91dCA9ICgpID0+IHtcclxuXHRjb25zdCBjaG9vc2VCbG9jayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pNS1hYm91dC1jaG9vc2UnKTtcclxuXHRjb25zdCBjaG9vc2VCbG9ja0FsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pNS1hYm91dC1jaG9vc2UtYmxvY2snKTtcclxuXHRjb25zdCBhYm91dENvbnRlbnRBbGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaTUtYWJvdXQtY29udGVudCcpO1xyXG5cclxuXHRjaG9vc2VCbG9jay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcblx0XHRpZiAoZS50YXJnZXQuY2xvc2VzdCgnLmk1LWFib3V0LWNob29zZS1ibG9jaycpKSB7XHJcblx0XHRcdGNob29zZUJsb2NrQWxsLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcblx0XHRcdFx0YWJvdXRDb250ZW50QWxsW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuXHRcdFx0XHRpZiAoaXRlbSA9PT0gZS50YXJnZXQuY2xvc2VzdCgnLmk1LWFib3V0LWNob29zZS1ibG9jaycpKSB7XHJcblx0XHRcdFx0XHRhYm91dENvbnRlbnRBbGxbaW5kZXhdLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGRlbicpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjaG9vc2VBYm91dDtcclxuIiwiZXhwb3J0IGNvbnN0IGNoZWNrQmVoYXZpb3IgPSAoYmVoYXZpb3IpID0+IHtcbiAgICByZXR1cm4gYmVoYXZpb3IgPT09IHVuZGVmaW5lZCB8fCBiZWhhdmlvciA9PT0gXCJhdXRvXCIgfHwgYmVoYXZpb3IgPT09IFwiaW5zdGFudFwiIHx8IGJlaGF2aW9yID09PSBcInNtb290aFwiO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50U2Nyb2xsWFkoeCwgeSkge1xuICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHg7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xufVxuZXhwb3J0IGNvbnN0IGZhaWxlZEV4ZWN1dGUgPSAobWV0aG9kLCBvYmplY3QsIHJlYXNvbiA9IFwiY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS5cIikgPT4gYEZhaWxlZCB0byBleGVjdXRlICcke21ldGhvZH0nIG9uICcke29iamVjdH0nOiAke3JlYXNvbn1gO1xuZXhwb3J0IGNvbnN0IGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlID0gKG1ldGhvZCwgb2JqZWN0LCB2YWx1ZSkgPT4gZmFpbGVkRXhlY3V0ZShtZXRob2QsIG9iamVjdCwgYFRoZSBwcm92aWRlZCB2YWx1ZSAnJHt2YWx1ZX0nIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBTY3JvbGxCZWhhdmlvci5gKTtcbi8qIGVzbGludC1kaXNhYmxlICovXG5leHBvcnQgY29uc3QgYmFja3VwTWV0aG9kID0gKHByb3RvLCBtZXRob2QsIGZhbGxiYWNrKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGJhY2t1cCA9IGBfX1NFQU1MRVNTLkJBQ0tVUCQke21ldGhvZH1gO1xuICAgIGlmICghcHJvdG9bYmFja3VwXSAmJiBwcm90b1ttZXRob2RdICYmICEoKF9hID0gcHJvdG9bbWV0aG9kXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9faXNQb2x5ZmlsbCkpIHtcbiAgICAgICAgcHJvdG9bYmFja3VwXSA9IHByb3RvW21ldGhvZF07XG4gICAgfVxuICAgIHJldHVybiBwcm90b1tiYWNrdXBdIHx8IGZhbGxiYWNrO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmICh0eXBlID09PSBcIm9iamVjdFwiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG59O1xuZXhwb3J0IGNvbnN0IGlzU2Nyb2xsQmVoYXZpb3JTdXBwb3J0ZWQgPSAoKSA9PiBcInNjcm9sbEJlaGF2aW9yXCIgaW4gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmV4cG9ydCBjb25zdCBtYXJrUG9seWZpbGwgPSAobWV0aG9kKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJfX2lzUG9seWZpbGxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07XG5leHBvcnQgY29uc3QgbW9kaWZ5UHJvdG90eXBlcyA9IChwcm9wLCBmdW5jKSA9PiB7XG4gICAgbWFya1BvbHlmaWxsKGZ1bmMpO1xuICAgIFtIVE1MRWxlbWVudC5wcm90b3R5cGUsIFNWR0VsZW1lbnQucHJvdG90eXBlLCBFbGVtZW50LnByb3RvdHlwZV0uZm9yRWFjaCgocHJvdG90eXBlKSA9PiB7XG4gICAgICAgIGJhY2t1cE1ldGhvZChwcm90b3R5cGUsIHByb3ApO1xuICAgICAgICBwcm90b3R5cGVbcHJvcF0gPSBmdW5jO1xuICAgIH0pO1xufTtcbi8qKlxuICogLSBPbiBDaHJvbWUgYW5kIEZpcmVmb3gsIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgd2lsbCByZXR1cm4gdGhlIDxodG1sPiBlbGVtZW50LlxuICogLSBTYWZhcmksIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgd2lsbCByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LlxuICogLSBPbiBFZGdlLCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHdpbGwgcmV0dXJuIHRoZSA8Ym9keT4gZWxlbWVudC5cbiAqIC0gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQsIGJ1dCB5b3UgY2FuIGFzc3VtZSBpdHMgPGh0bWw+LlxuICovXG5leHBvcnQgY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IChlbGVtZW50KSA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCIsImNvbnN0IGVhc2UgPSAoaykgPT4ge1xuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBmbjtcbiAgICBpZiAoKF9hID0gd2luZG93LnBlcmZvcm1hbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm93KSB7XG4gICAgICAgIGZuID0gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm4gPSAoKSA9PiB3aW5kb3cuRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG5vdyA9IGZuO1xuICAgIHJldHVybiBmbigpO1xufVxuLyogZXNsaW50LWVuYWJsZSAqL1xuY29uc3QgRFVSQVRJT04gPSA1MDA7XG5leHBvcnQgY29uc3Qgc3RlcCA9IChjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gKGN1cnJlbnRUaW1lIC0gY29udGV4dC50aW1lU3RhbXApIC8gKGNvbnRleHQuZHVyYXRpb24gfHwgRFVSQVRJT04pO1xuICAgIGlmIChlbGFwc2VkID4gMSkge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZChjb250ZXh0LnRhcmdldFgsIGNvbnRleHQudGFyZ2V0WSk7XG4gICAgICAgIGNvbnRleHQuY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IChjb250ZXh0LnRpbWluZ0Z1bmMgfHwgZWFzZSkoZWxhcHNlZCk7XG4gICAgY29uc3QgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnRhcmdldFggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICBjb25zdCBjdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQudGFyZ2V0WSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuICAgIGNvbnRleHQubWV0aG9kKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgY29udGV4dC5yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzdGVwKGNvbnRleHQpO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC1zdGVwLmpzLm1hcCIsImltcG9ydCB7IGJhY2t1cE1ldGhvZCwgY2hlY2tCZWhhdmlvciwgZWxlbWVudFNjcm9sbFhZLCBmYWlsZWRFeGVjdXRlLCBmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZSwgaXNPYmplY3QsIHNjcm9sbGluZ0VsZW1lbnQsIH0gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBub3csIHN0ZXAgfSBmcm9tIFwiLi9zY3JvbGwtc3RlcC5qc1wiO1xuLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLXZpZXcvI25vcm1hbGl6ZS1ub24tZmluaXRlLXZhbHVlc1xuY29uc3Qgbm9uRmluaXRlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xufTtcbmNvbnN0IGlzQ29ubmVjdGVkID0gKG5vZGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBub2RlLmlzQ29ubmVjdGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoIW5vZGUub3duZXJEb2N1bWVudCB8fFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAhKG5vZGUub3duZXJEb2N1bWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIC8qKiBET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgKi8gMSkpKTtcbn07XG5jb25zdCBzY3JvbGxXaXRoT3B0aW9ucyA9IChlbGVtZW50LCBvcHRpb25zLCBjb25maWcpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghaXNDb25uZWN0ZWQoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgY29uc3Qgc3RhcnRZID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgY29uc3QgdGFyZ2V0WCA9IG5vbkZpbml0ZSgoX2EgPSBvcHRpb25zLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0YXJ0WCk7XG4gICAgY29uc3QgdGFyZ2V0WSA9IG5vbkZpbml0ZSgoX2IgPSBvcHRpb25zLnRvcCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogc3RhcnRZKTtcbiAgICBpZiAodGFyZ2V0WCA9PT0gc3RhcnRYICYmIHRhcmdldFkgPT09IHN0YXJ0WSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZhbGxiYWNrID0gYmFja3VwTWV0aG9kKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgXCJzY3JvbGxcIiwgZWxlbWVudFNjcm9sbFhZKTtcbiAgICBjb25zdCBtZXRob2QgPSBiYWNrdXBNZXRob2QoT2JqZWN0LmdldFByb3RvdHlwZU9mKGVsZW1lbnQpLCBcInNjcm9sbFwiLCBmYWxsYmFjaykuYmluZChlbGVtZW50KTtcbiAgICBpZiAob3B0aW9ucy5iZWhhdmlvciAhPT0gXCJzbW9vdGhcIikge1xuICAgICAgICBtZXRob2QodGFyZ2V0WCwgdGFyZ2V0WSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBjYW5jZWxTY3JvbGwpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBjYW5jZWxTY3JvbGwpO1xuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyB0aW1lU3RhbXA6IG5vdygpLCBzdGFydFgsXG4gICAgICAgIHN0YXJ0WSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSwgcmFmSWQ6IDAsIG1ldGhvZCwgY2FsbGJhY2s6IHJlbW92ZUV2ZW50TGlzdGVuZXIgfSk7XG4gICAgY29uc3QgY2FuY2VsU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoY29udGV4dC5yYWZJZCk7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgY2FuY2VsU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgY2FuY2VsU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgfSk7XG4gICAgc3RlcChjb250ZXh0KTtcbn07XG5jb25zdCBpc1dpbmRvdyA9IChvYmopID0+IG9iai53aW5kb3cgPT09IG9iajtcbmNvbnN0IGNyZWF0ZVNjcm9sbCA9IChzY3JvbGxOYW1lKSA9PiAodGFyZ2V0LCBzY3JvbGxPcHRpb25zLCBjb25maWcpID0+IHtcbiAgICBjb25zdCBbZWxlbWVudCwgc2Nyb2xsVHlwZV0gPSBpc1dpbmRvdyh0YXJnZXQpXG4gICAgICAgID8gW3Njcm9sbGluZ0VsZW1lbnQodGFyZ2V0LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCksIFwiV2luZG93XCJdXG4gICAgICAgIDogW3RhcmdldCwgXCJFbGVtZW50XCJdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzY3JvbGxPcHRpb25zICE9PSBudWxsICYmIHNjcm9sbE9wdGlvbnMgIT09IHZvaWQgMCA/IHNjcm9sbE9wdGlvbnMgOiB7fTtcbiAgICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZmFpbGVkRXhlY3V0ZShzY3JvbGxOYW1lLCBzY3JvbGxUeXBlKSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tCZWhhdmlvcihvcHRpb25zLmJlaGF2aW9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlKHNjcm9sbE5hbWUsIHNjcm9sbFR5cGUsIG9wdGlvbnMuYmVoYXZpb3IpKTtcbiAgICB9XG4gICAgaWYgKHNjcm9sbE5hbWUgPT09IFwic2Nyb2xsQnlcIikge1xuICAgICAgICBvcHRpb25zLmxlZnQgPSBub25GaW5pdGUob3B0aW9ucy5sZWZ0KSArIGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgb3B0aW9ucy50b3AgPSBub25GaW5pdGUob3B0aW9ucy50b3ApICsgZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfVxuICAgIHNjcm9sbFdpdGhPcHRpb25zKGVsZW1lbnQsIG9wdGlvbnMsIGNvbmZpZyk7XG59O1xuZXhwb3J0IGNvbnN0IHNjcm9sbCA9IC8qICNfX1BVUkVfXyAqLyBjcmVhdGVTY3JvbGwoXCJzY3JvbGxcIik7XG5leHBvcnQgY29uc3Qgc2Nyb2xsVG8gPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlU2Nyb2xsKFwic2Nyb2xsVG9cIik7XG5leHBvcnQgY29uc3Qgc2Nyb2xsQnkgPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlU2Nyb2xsKFwic2Nyb2xsQnlcIik7XG5leHBvcnQgY29uc3QgZWxlbWVudFNjcm9sbCA9IHNjcm9sbDtcbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsVG8gPSBzY3JvbGxUbztcbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsQnkgPSBzY3JvbGxCeTtcbmV4cG9ydCBjb25zdCB3aW5kb3dTY3JvbGwgPSBzY3JvbGw7XG5leHBvcnQgY29uc3Qgd2luZG93U2Nyb2xsVG8gPSBzY3JvbGxUbztcbmV4cG9ydCBjb25zdCB3aW5kb3dTY3JvbGxCeSA9IHNjcm9sbEJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmltcG9ydCB7IGNoZWNrQmVoYXZpb3IsIGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlLCBzY3JvbGxpbmdFbGVtZW50IH0gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBlbGVtZW50U2Nyb2xsIH0gZnJvbSBcIi4vc2Nyb2xsLmpzXCI7XG4vLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMtNC8jYmxvY2stZmxvd1xuY29uc3Qgbm9ybWFsaXplV3JpdGluZ01vZGUgPSAod3JpdGluZ01vZGUpID0+IHtcbiAgICBzd2l0Y2ggKHdyaXRpbmdNb2RlKSB7XG4gICAgICAgIGNhc2UgXCJob3Jpem9udGFsLXRiXCI6XG4gICAgICAgIGNhc2UgXCJsclwiOlxuICAgICAgICBjYXNlIFwibHItdGJcIjpcbiAgICAgICAgY2FzZSBcInJsXCI6XG4gICAgICAgIGNhc2UgXCJybC10YlwiOlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogSG9yaXpvbnRhbFRiICovO1xuICAgICAgICBjYXNlIFwidmVydGljYWwtcmxcIjpcbiAgICAgICAgY2FzZSBcInRiXCI6XG4gICAgICAgIGNhc2UgXCJ0Yi1ybFwiOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogVmVydGljYWxSbCAqLztcbiAgICAgICAgY2FzZSBcInZlcnRpY2FsLWxyXCI6XG4gICAgICAgIGNhc2UgXCJ0Yi1sclwiOlxuICAgICAgICAgICAgcmV0dXJuIDIgLyogVmVydGljYWxMciAqLztcbiAgICAgICAgY2FzZSBcInNpZGV3YXlzLXJsXCI6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBTaWRld2F5c1JsICovO1xuICAgICAgICBjYXNlIFwic2lkZXdheXMtbHJcIjpcbiAgICAgICAgICAgIHJldHVybiA0IC8qIFNpZGV3YXlzTHIgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEhvcml6b250YWxUYiAqLztcbn07XG5jb25zdCBjYWxjUGh5c2ljYWxBeGlzID0gKHdyaXRpbmdNb2RlLCBpc0xUUiwgaFBvcywgdlBvcykgPT4ge1xuICAgIC8qKiAgMGJ7dmVydGljYWx9e2hvcml6b250YWx9ICAwOiBub3JtYWwsIDE6IHJldmVyc2UgKi9cbiAgICBsZXQgbGF5b3V0ID0gMGIwMDtcbiAgICAvKipcbiAgICAgKiBXcml0aW5nTW9kZS5WZXJ0aWNhbExyOiDihpPihpJcbiAgICAgKiB8IDEgfCA0IHwgICB8XG4gICAgICogfCAyIHwgNSB8ICAgfFxuICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgKlxuICAgICAqIFJUTDog4oaR4oaSXG4gICAgICogfCAzIHwgICB8ICAgfFxuICAgICAqIHwgMiB8IDUgfCAgIHxcbiAgICAgKiB8IDEgfCA0IHwgICB8XG4gICAgICovXG4gICAgaWYgKCFpc0xUUikge1xuICAgICAgICBsYXlvdXQgXj0gMiAvKiBSZXZlcnNlVmVydGljYWwgKi87XG4gICAgfVxuICAgIHN3aXRjaCAod3JpdGluZ01vZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOKGk+KGklxuICAgICAgICAgKiB8IDEgfCAyIHwgMyB8XG4gICAgICAgICAqIHwgNCB8IDUgfCAgIHxcbiAgICAgICAgICogfCAgIHwgICB8ICAgfFxuICAgICAgICAgKlxuICAgICAgICAgKiBSVEw6IOKGk+KGkFxuICAgICAgICAgKiB8IDMgfCAyIHwgMSB8XG4gICAgICAgICAqIHwgICB8IDUgfCA0IHxcbiAgICAgICAgICogfCAgIHwgICB8ICAgfFxuICAgICAgICAgKi9cbiAgICAgICAgY2FzZSAwIC8qIEhvcml6b250YWxUYiAqLzpcbiAgICAgICAgICAgIC8vIHN3YXAgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAgICAgICAgICAgIGxheW91dCA9IChsYXlvdXQgPj4gMSkgfCAoKGxheW91dCAmIDEpIDw8IDEpO1xuICAgICAgICAgICAgW2hQb3MsIHZQb3NdID0gW3ZQb3MsIGhQb3NdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDihpPihpBcbiAgICAgICAgICogfCAgIHwgNCB8IDEgfFxuICAgICAgICAgKiB8ICAgfCA1IHwgMiB8XG4gICAgICAgICAqIHwgICB8ICAgfCAzIHxcbiAgICAgICAgICpcbiAgICAgICAgICogUlRMOiDihpHihpBcbiAgICAgICAgICogfCAgIHwgICB8IDMgfFxuICAgICAgICAgKiB8ICAgfCA1IHwgMiB8XG4gICAgICAgICAqIHwgICB8IDQgfCAxIHxcbiAgICAgICAgICovXG4gICAgICAgIGNhc2UgMSAvKiBWZXJ0aWNhbFJsICovOlxuICAgICAgICBjYXNlIDMgLyogU2lkZXdheXNSbCAqLzpcbiAgICAgICAgICAgIC8vICByZXZlcnNlIGhvcml6b250YWxcbiAgICAgICAgICAgIGxheW91dCBePSAxIC8qIFJldmVyc2VIb3Jpem9udGFsICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDihpHihpJcbiAgICAgICAgICogfCAzIHwgICB8ICAgfFxuICAgICAgICAgKiB8IDIgfCA1IHwgICB8XG4gICAgICAgICAqIHwgMSB8IDQgfCAgIHxcbiAgICAgICAgICpcbiAgICAgICAgICogUlRMOiDihpPihpJcbiAgICAgICAgICogfCAxIHwgNCB8ICAgfFxuICAgICAgICAgKiB8IDIgfCA1IHwgICB8XG4gICAgICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgICAgICovXG4gICAgICAgIGNhc2UgNCAvKiBTaWRld2F5c0xyICovOlxuICAgICAgICAgICAgLy8gcmV2ZXJzZSB2ZXJ0aWNhbFxuICAgICAgICAgICAgbGF5b3V0IF49IDIgLyogUmV2ZXJzZVZlcnRpY2FsICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBbbGF5b3V0LCBoUG9zLCB2UG9zXTtcbn07XG5jb25zdCBpc1hSZXZlcnNlZCA9IChjb21wdXRlZFN0eWxlKSA9PiB7XG4gICAgY29uc3QgbGF5b3V0ID0gY2FsY1BoeXNpY2FsQXhpcyhub3JtYWxpemVXcml0aW5nTW9kZShjb21wdXRlZFN0eWxlLndyaXRpbmdNb2RlKSwgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gIT09IFwicnRsXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVswXTtcbiAgICByZXR1cm4gKGxheW91dCAmIDEpID09PSAxO1xufTtcbi8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnRoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvZG9tL2VsZW1lbnQuY2M7bD0xMDk3LTExODk7ZHJjPTZhNzUzM2Q0YTFlOWYyMzcyMjIzYTlkOTEyYTllNTNhNmZhMzVhZTBcbmNvbnN0IHRvUGh5c2ljYWxBbGlnbm1lbnQgPSAob3B0aW9ucywgd3JpdGluZ01vZGUsIGlzTFRSKSA9PiB7XG4gICAgY29uc3QgW2xheW91dCwgaFBvcywgdlBvc10gPSBjYWxjUGh5c2ljYWxBeGlzKHdyaXRpbmdNb2RlLCBpc0xUUiwgb3B0aW9ucy5ibG9jayB8fCBcInN0YXJ0XCIsIG9wdGlvbnMuaW5saW5lIHx8IFwibmVhcmVzdFwiKTtcbiAgICByZXR1cm4gW2hQb3MsIHZQb3NdLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBDZW50ZXJBbHdheXMgKi87XG4gICAgICAgICAgICBjYXNlIFwibmVhcmVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIFRvRWRnZUlmTmVlZGVkICovO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2UgPSAobGF5b3V0ID4+IGluZGV4KSAmIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gXCJzdGFydFwiKSA9PT0gIXJldmVyc2UgPyAyIC8qIExlZnRPclRvcCAqLyA6IDMgLyogUmlnaHRPckJvdHRvbSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8vIGNvZGUgZnJvbSBzdGlwc2FuL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlld1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N0aXBzYW4vY29tcHV0ZS1zY3JvbGwtaW50by12aWV3L2Jsb2IvNTM5NmM2Yjc4YWY1ZDBiYmNlMTFhN2M0ZTkzY2MzMTQ2NTQ2ZmNkMy9zcmMvaW5kZXgudHNcbi8qKlxuICogRmluZCBvdXQgd2hpY2ggZWRnZSB0byBhbGlnbiBhZ2FpbnN0IHdoZW4gbG9naWNhbCBzY3JvbGwgcG9zaXRpb24gaXMgXCJuZWFyZXN0XCJcbiAqIEludGVyZXN0aW5nIGZhY3Q6IFwibmVhcmVzdFwiIHdvcmtzIHNpbWlsYXJpbHkgdG8gXCJpZi1uZWVkZWRcIiwgaWYgdGhlIGVsZW1lbnQgaXMgZnVsbHkgdmlzaWJsZSBpdCB3aWxsIG5vdCBzY3JvbGwgaXRcbiAqXG4gKiBMZWdlbmRzOlxuICog4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUjyDilIEg4pSBIOKUgSDilJNcbiAqIOKUgiB0YXJnZXQg4pSCICAgZnJhbWVcbiAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilJcg4pSBIOKUgSDilIEg4pSbXG4gKi9cbmNvbnN0IG1hcE5lYXJlc3QgPSAoYWxpZ24sIHNjcm9sbGluZ0VkZ2VTdGFydCwgc2Nyb2xsaW5nRWRnZUVuZCwgc2Nyb2xsaW5nU2l6ZSwgZWxlbWVudEVkZ2VTdGFydCwgZWxlbWVudEVkZ2VFbmQsIGVsZW1lbnRTaXplKSA9PiB7XG4gICAgaWYgKGFsaWduICE9PSAwIC8qIFRvRWRnZUlmTmVlZGVkICovKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEEgYW5kIGVsZW1lbnQgZWRnZSBCIGFyZSBib3RoIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEEgYW5kIHNjcm9sbGluZyBib3ggZWRnZSBCXG4gICAgICpcbiAgICAgKiAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgKiAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTXG4gICAgICogICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAg4pSDIOKUgiAg4pSCIOKUgyAgICAgICAgZG8gbm90aGluZ1xuICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUl+KUgeKUguKUgeKUgeKUguKUgeKUm1xuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAqXG4gICAgICogIElmIGVsZW1lbnQgZWRnZSBDIGFuZCBlbGVtZW50IGVkZ2UgRCBhcmUgYm90aCBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBDIGFuZCBzY3JvbGxpbmcgYm94IGVkZ2UgRFxuICAgICAqXG4gICAgICogICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAqICAg4pSC4pSDICAgICAgICAg4pSD4pSCICAgICAgICBkbyBub3RoaW5nXG4gICAgICogICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAgKiAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqL1xuICAgIGlmICgoZWxlbWVudEVkZ2VTdGFydCA8IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50RWRnZUVuZCA+IHNjcm9sbGluZ0VkZ2VFbmQpIHx8XG4gICAgICAgIChlbGVtZW50RWRnZVN0YXJ0ID4gc2Nyb2xsaW5nRWRnZVN0YXJ0ICYmIGVsZW1lbnRFZGdlRW5kIDwgc2Nyb2xsaW5nRWRnZUVuZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEEgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICogICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUkyAgICAgICAgIOKUj+KUgeKUjOKUgeKUgeKUkOKUgeKUk1xuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmCAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICBmcm9tICDilIMgICAgICDilIMgICAgIHRvICDilIMg4pSU4pSA4pSA4pSYIOKUg1xuICAgICAqXG4gICAgICogICAgICAgIOKUl+KUgSDilIHilIEg4pSB4pSbICAgICAgICAg4pSX4pSBIOKUgeKUgSDilIHilJtcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBCIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEIgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgIOKUj+KUgSDilIHilIEg4pSB4pSTICAgICAgICAg4pSP4pSB4pSM4pSB4pSB4pSQ4pSB4pSTXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICBmcm9tICDilIMg4pSM4pSA4pSA4pSQIOKUgyAgICAgdG8gIOKUgyDilIIgIOKUgiDilINcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIHilILilIHilIHilILilIHilJsgICAgICAgICDilJfilIHilILilIHilIHilILilIHilJtcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEMgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQyBhbmQgZWxlbWVudCB3aWR0aCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgKiAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogIOKUjOKUgOKUgOKUgOKUkCAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXG4gICAgICogIOKUgiDilIMg4pSCICAgICAgIOKUgyAgICAgICAgIOKUgyAgIOKUgiAgICAg4pSDXG4gICAgICogIOKUlOKUgOKUgOKUgOKUmCAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXG4gICAgICogICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEQgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgRCBhbmQgZWxlbWVudCB3aWR0aCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgKiAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAqICAgIOKUgyAgIOKUgiAgICAg4pSDICAgICDilIIgICDilIMgICAgICAgICDilIMg4pSCXG4gICAgICogICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgICAqICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKi9cbiAgICBpZiAoKGVsZW1lbnRFZGdlU3RhcnQgPD0gc2Nyb2xsaW5nRWRnZVN0YXJ0ICYmIGVsZW1lbnRTaXplIDw9IHNjcm9sbGluZ1NpemUpIHx8XG4gICAgICAgIChlbGVtZW50RWRnZUVuZCA+PSBzY3JvbGxpbmdFZGdlRW5kICYmIGVsZW1lbnRTaXplID49IHNjcm9sbGluZ1NpemUpKSB7XG4gICAgICAgIHJldHVybiAyIC8qIExlZnRPclRvcCAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEIgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQiBhbmQgZWxlbWVudCBoZWlnaHQgaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggaGVpZ2h0XG4gICAgICpcbiAgICAgKiAgICAgICAg4pSP4pSBIOKUgeKUgSDilIHilJMgICAgICAgICDilI/ilIEg4pSB4pSBIOKUgeKUk1xuICAgICAqXG4gICAgICogIGZyb20gIOKUgyAgICAgIOKUgyAgICAgdG8gIOKUgyDilIzilIDilIDilJAg4pSDXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUl+KUgeKUguKUgeKUgeKUguKUgeKUmyAgICAgICAgIOKUl+KUgeKUlOKUgeKUgeKUmOKUgeKUm1xuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEEgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQSBhbmQgZWxlbWVudCBoZWlnaHQgaXMgZ3JlYXRlciB0aGFuIHNjcm9sbGluZyBib3ggaGVpZ2h0XG4gICAgICpcbiAgICAgKiAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUjOKUgOKUgOKUkFxuICAgICAqICAgICAgICDilI/ilIHilILilIHilIHilILilIHilJMgICAgICAgICDilI/ilIHilILilIHilIHilILilIHilJNcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICBmcm9tICDilIMg4pSU4pSA4pSA4pSYIOKUgyAgICAgdG8gIOKUgyDilIIgIOKUgiDilINcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUl+KUgSDilIHilIEg4pSB4pSbICAgICAgICAg4pSX4pSB4pSU4pSB4pSB4pSY4pSB4pSbXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQyBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBDIGFuZCBlbGVtZW50IHdpZHRoIGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IHdpZHRoXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgKiAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJMgICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAqICDilIIgICAgIOKUgyAgICAg4pSCICAg4pSDICAgICAgIOKUgiDilIMgICAgICAgICDilINcbiAgICAgKiAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAgKiAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEQgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgRCBhbmQgZWxlbWVudCB3aWR0aCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAgICAgICAgICAgICAgICDilIzilIDilIDilIDilJAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXG4gICAgICogICAgICAgIOKUgyAgICAgICDilIIg4pSDIOKUgiAgICAgICDilIMgICAgIOKUgiAgIOKUg1xuICAgICAqICAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmCAgICAgICAgICAgICDilJTilIDilIDilIDilJhcbiAgICAgKiAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqXG4gICAgICovXG4gICAgaWYgKChlbGVtZW50RWRnZUVuZCA+IHNjcm9sbGluZ0VkZ2VFbmQgJiYgZWxlbWVudFNpemUgPCBzY3JvbGxpbmdTaXplKSB8fFxuICAgICAgICAoZWxlbWVudEVkZ2VTdGFydCA8IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50U2l6ZSA+IHNjcm9sbGluZ1NpemUpKSB7XG4gICAgICAgIHJldHVybiAzIC8qIFJpZ2h0T3JCb3R0b20gKi87XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGNhbk92ZXJmbG93ID0gKG92ZXJmbG93KSA9PiB7XG4gICAgcmV0dXJuIG92ZXJmbG93ICE9PSBcInZpc2libGVcIiAmJiBvdmVyZmxvdyAhPT0gXCJjbGlwXCI7XG59O1xuY29uc3QgZ2V0RnJhbWVFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcmFtZUVsZW1lbnQpIHx8IG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChfYikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuY29uc3QgaXNTY3JvbGxhYmxlID0gKGVsZW1lbnQsIGNvbXB1dGVkU3R5bGUpID0+IHtcbiAgICBpZiAoZWxlbWVudC5jbGllbnRIZWlnaHQgPCBlbGVtZW50LnNjcm9sbEhlaWdodCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aCkge1xuICAgICAgICByZXR1cm4gKGNhbk92ZXJmbG93KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZKSB8fFxuICAgICAgICAgICAgY2FuT3ZlcmZsb3coY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpIHx8XG4gICAgICAgICAgICBlbGVtZW50ID09PSBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IHBhcmVudEVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHBOb2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGNvbnN0IHBFbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChwRWxlbWVudCA9PT0gbnVsbCAmJiBwTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocE5vZGUubm9kZVR5cGUgPT09IC8qKiBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgKi8gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBwTm9kZS5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwTm9kZS5ub2RlVHlwZSA9PT0gLyoqIE5vZGUuRE9DVU1FTlRfTk9ERSAqLyA5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwRWxlbWVudDtcbn07XG5jb25zdCBjbGFtcCA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBnZXRTdXBwb3J0ZWRTY3JvbGxNYXJnaW5Qcm9wZXJ0eSA9IChvd25lckRvY3VtZW50KSA9PiB7XG4gICAgLy8gV2Via2l0IHVzZXMgXCJzY3JvbGwtc25hcC1tYXJnaW5cIiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg5MjY1LlxuICAgIHJldHVybiBbXCJzY3JvbGwtbWFyZ2luXCIsIFwic2Nyb2xsLXNuYXAtbWFyZ2luXCJdLmZpbHRlcigocHJvcGVydHkpID0+IHByb3BlcnR5IGluIG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKVswXTtcbn07XG5jb25zdCBnZXRFbGVtZW50U2Nyb2xsU25hcEFyZWEgPSAoZWxlbWVudCwgZWxlbWVudFJlY3QsIGNvbXB1dGVkU3R5bGUpID0+IHtcbiAgICBjb25zdCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9ID0gZWxlbWVudFJlY3Q7XG4gICAgY29uc3Qgc2Nyb2xsUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRTY3JvbGxNYXJnaW5Qcm9wZXJ0eShlbGVtZW50Lm93bmVyRG9jdW1lbnQpO1xuICAgIGlmICghc2Nyb2xsUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxNYXJnaW5WYWx1ZSA9IChlZGdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGAke3Njcm9sbFByb3BlcnR5fS0ke2VkZ2V9YCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XG4gICAgfTtcbiAgICByZXR1cm4gW1xuICAgICAgICB0b3AgLSBzY3JvbGxNYXJnaW5WYWx1ZShcInRvcFwiKSxcbiAgICAgICAgcmlnaHQgKyBzY3JvbGxNYXJnaW5WYWx1ZShcInJpZ2h0XCIpLFxuICAgICAgICBib3R0b20gKyBzY3JvbGxNYXJnaW5WYWx1ZShcImJvdHRvbVwiKSxcbiAgICAgICAgbGVmdCAtIHNjcm9sbE1hcmdpblZhbHVlKFwibGVmdFwiKSxcbiAgICBdO1xufTtcbmNvbnN0IGNhbGNBbGlnbkVkZ2UgPSAoYWxpZ24sIHN0YXJ0LCBlbmQpID0+IHtcbiAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgMSAvKiBDZW50ZXJBbHdheXMgKi86XG4gICAgICAgICAgICByZXR1cm4gKHN0YXJ0ICsgZW5kKSAvIDI7XG4gICAgICAgIGNhc2UgMyAvKiBSaWdodE9yQm90dG9tICovOlxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgY2FzZSAyIC8qIExlZnRPclRvcCAqLzpcbiAgICAgICAgY2FzZSAwIC8qIFRvRWRnZUlmTmVlZGVkICovOlxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbn07XG5jb25zdCBnZXRGcmFtZVZpZXdwb3J0ID0gKGZyYW1lLCBmcmFtZVJlY3QpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IChfYSA9IGZyYW1lLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aXN1YWxWaWV3cG9ydDtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBmcmFtZSA9PT0gc2Nyb2xsaW5nRWxlbWVudChmcmFtZSlcbiAgICAgICAgPyBbMCwgMCwgKF9iID0gdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgdmlzdWFsVmlld3BvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbFZpZXdwb3J0LndpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmcmFtZS5jbGllbnRXaWR0aCwgKF9jID0gdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgdmlzdWFsVmlld3BvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbFZpZXdwb3J0LmhlaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZnJhbWUuY2xpZW50SGVpZ2h0XVxuICAgICAgICA6IFtmcmFtZVJlY3QubGVmdCwgZnJhbWVSZWN0LnRvcCwgZnJhbWUuY2xpZW50V2lkdGgsIGZyYW1lLmNsaWVudEhlaWdodF07XG4gICAgY29uc3QgbGVmdCA9IHggKyBmcmFtZS5jbGllbnRMZWZ0O1xuICAgIGNvbnN0IHRvcCA9IHkgKyBmcmFtZS5jbGllbnRUb3A7XG4gICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XTtcbn07XG5jb25zdCBjb21wdXRlU2Nyb2xsSW50b1ZpZXcgPSAoZWxlbWVudCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIENvbGxlY3QgYWxsIHRoZSBzY3JvbGxpbmcgYm94ZXMsIGFzIGRlZmluZWQgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS12aWV3LyNzY3JvbGxpbmctYm94XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgIGxldCBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIGxldCBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFvd25lcldpbmRvdykge1xuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzTFRSID0gY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gIT09IFwicnRsXCI7XG4gICAgY29uc3Qgd3JpdGluZ01vZGUgPSBub3JtYWxpemVXcml0aW5nTW9kZShjb21wdXRlZFN0eWxlLndyaXRpbmdNb2RlIHx8XG4gICAgICAgIGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi13ZWJraXQtd3JpdGluZy1tb2RlXCIpIHx8XG4gICAgICAgIGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi1tcy13cml0aW5nLW1vZGVcIikpO1xuICAgIGNvbnN0IFthbGlnbkgsIGFsaWduVl0gPSB0b1BoeXNpY2FsQWxpZ25tZW50KG9wdGlvbnMsIHdyaXRpbmdNb2RlLCBpc0xUUik7XG4gICAgbGV0IFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdID0gZ2V0RWxlbWVudFNjcm9sbFNuYXBBcmVhKGVsZW1lbnQsIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGNvbXB1dGVkU3R5bGUpO1xuICAgIGZvciAobGV0IGZyYW1lID0gcGFyZW50RWxlbWVudChlbGVtZW50KTsgZnJhbWUgIT09IG51bGw7IGZyYW1lID0gcGFyZW50RWxlbWVudChmcmFtZSkpIHtcbiAgICAgICAgaWYgKG93bmVyRG9jdW1lbnQgIT09IGZyYW1lLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBmcmFtZS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgaWYgKCFvd25lcldpbmRvdykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBsZWZ0OiBkWCwgdG9wOiBkWSB9ID0gZnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3AgKz0gZFk7XG4gICAgICAgICAgICByaWdodCArPSBkWDtcbiAgICAgICAgICAgIGJvdHRvbSArPSBkWTtcbiAgICAgICAgICAgIGxlZnQgKz0gZFg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoZnJhbWUpO1xuICAgICAgICBpZiAoZnJhbWVTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU2Nyb2xsYWJsZShmcmFtZSwgZnJhbWVTdHlsZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lUmVjdCA9IGZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBbZnJhbWVUb3AsIGZyYW1lUmlnaHQsIGZyYW1lQm90dG9tLCBmcmFtZUxlZnRdID0gZ2V0RnJhbWVWaWV3cG9ydChmcmFtZSwgZnJhbWVSZWN0KTtcbiAgICAgICAgY29uc3QgZUFsaWduSCA9IG1hcE5lYXJlc3QoYWxpZ25ILCBmcmFtZUxlZnQsIGZyYW1lUmlnaHQsIGZyYW1lLmNsaWVudFdpZHRoLCBsZWZ0LCByaWdodCwgcmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgZUFsaWduViA9IG1hcE5lYXJlc3QoYWxpZ25WLCBmcmFtZVRvcCwgZnJhbWVCb3R0b20sIGZyYW1lLmNsaWVudEhlaWdodCwgdG9wLCBib3R0b20sIGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIGNvbnN0IGRpZmZYID0gZUFsaWduSCA9PT0gbnVsbCA/IDAgOiBjYWxjQWxpZ25FZGdlKGVBbGlnbkgsIGxlZnQsIHJpZ2h0KSAtIGNhbGNBbGlnbkVkZ2UoZUFsaWduSCwgZnJhbWVMZWZ0LCBmcmFtZVJpZ2h0KTtcbiAgICAgICAgY29uc3QgZGlmZlkgPSBlQWxpZ25WID09PSBudWxsID8gMCA6IGNhbGNBbGlnbkVkZ2UoZUFsaWduViwgdG9wLCBib3R0b20pIC0gY2FsY0FsaWduRWRnZShlQWxpZ25WLCBmcmFtZVRvcCwgZnJhbWVCb3R0b20pO1xuICAgICAgICBjb25zdCBtb3ZlWCA9IGlzWFJldmVyc2VkKGZyYW1lU3R5bGUpXG4gICAgICAgICAgICA/IGNsYW1wKGRpZmZYLCAtZnJhbWUuc2Nyb2xsV2lkdGggKyBmcmFtZS5jbGllbnRXaWR0aCAtIGZyYW1lLnNjcm9sbExlZnQsIC1mcmFtZS5zY3JvbGxMZWZ0KVxuICAgICAgICAgICAgOiBjbGFtcChkaWZmWCwgLWZyYW1lLnNjcm9sbExlZnQsIGZyYW1lLnNjcm9sbFdpZHRoIC0gZnJhbWUuY2xpZW50V2lkdGggLSBmcmFtZS5zY3JvbGxMZWZ0KTtcbiAgICAgICAgY29uc3QgbW92ZVkgPSBjbGFtcChkaWZmWSwgLWZyYW1lLnNjcm9sbFRvcCwgZnJhbWUuc2Nyb2xsSGVpZ2h0IC0gZnJhbWUuY2xpZW50SGVpZ2h0IC0gZnJhbWUuc2Nyb2xsVG9wKTtcbiAgICAgICAgYWN0aW9ucy5wdXNoKFtcbiAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgeyBsZWZ0OiBmcmFtZS5zY3JvbGxMZWZ0ICsgbW92ZVgsIHRvcDogZnJhbWUuc2Nyb2xsVG9wICsgbW92ZVksIGJlaGF2aW9yOiBvcHRpb25zLmJlaGF2aW9yIH0sXG4gICAgICAgIF0pO1xuICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AgLSBtb3ZlWSwgZnJhbWVUb3ApO1xuICAgICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0IC0gbW92ZVgsIGZyYW1lUmlnaHQpO1xuICAgICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20gLSBtb3ZlWSwgZnJhbWVCb3R0b20pO1xuICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCAtIG1vdmVYLCBmcmFtZUxlZnQpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9ucztcbn07XG5leHBvcnQgY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAoZWxlbWVudCwgc2Nyb2xsSW50b1ZpZXdPcHRpb25zLCBjb25maWcpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gc2Nyb2xsSW50b1ZpZXdPcHRpb25zIHx8IHt9O1xuICAgIGlmICghY2hlY2tCZWhhdmlvcihvcHRpb25zLmJlaGF2aW9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlKFwic2Nyb2xsSW50b1ZpZXdcIiwgXCJFbGVtZW50XCIsIG9wdGlvbnMuYmVoYXZpb3IpKTtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9ucyA9IGNvbXB1dGVTY3JvbGxJbnRvVmlldyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICBhY3Rpb25zLmZvckVhY2goKFtmcmFtZSwgc2Nyb2xsVG9PcHRpb25zXSkgPT4ge1xuICAgICAgICBlbGVtZW50U2Nyb2xsKGZyYW1lLCBzY3JvbGxUb09wdGlvbnMsIGNvbmZpZyk7XG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IGVsZW1lbnRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsSW50b1ZpZXcuanMubWFwIiwiaW1wb3J0IHsgZWxlbWVudFNjcm9sbEludG9WaWV3IH0gZnJvbSAnc2VhbWxlc3Mtc2Nyb2xsLXBvbHlmaWxsJztcclxuXHJcbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gKCkgPT4ge1xyXG5cdGNvbnN0IGhlYWRlck1lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaGVhZGVyLW1lbnUnKTtcclxuXHJcblx0Y29uc3Qgc2Nyb2xsVXAgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcblx0XHRlbGVtZW50U2Nyb2xsSW50b1ZpZXcob2JqZWN0LCB7IGJlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInLCBpbmxpbmU6ICdjZW50ZXInIH0pO1xyXG5cdH07XHJcblxyXG5cdGhlYWRlck1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG5cdFx0aWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaGVhZGVyLW1lbnUtaXRlbScpKSB7XHJcblx0XHRcdGNvbnN0IGl0ZW1MaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJykuc3Vic3RyaW5nKDEpKTtcclxuXHRcdFx0c2Nyb2xsVXAuYmluZChpdGVtTGluaykoaXRlbUxpbmspO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2Nyb2xsSW50b1ZpZXc7XHJcbiIsImNvbnN0IGNoYW5nZVRoZW1lID0gKCkgPT4ge1xyXG5cdGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFuZ2UtdGhlbWUtYnV0dG9uJyk7XHJcblxyXG5cdGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XHJcblx0Y29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlcicpO1xyXG5cdGNvbnN0IGhlYWRlck1lbnVUaGVtZUJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXItbWVudS10aGVtZS1idXR0b24nKTtcclxuXHRjb25zdCBpMlNraWxsc0l0ZW1Cb3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaTItc2tpbGxzLWl0ZW0tYm94Jyk7XHJcblx0Y29uc3QgZm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvb3RlcicpO1xyXG5cdGNvbnN0IGl0ZW0xID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmkxJyk7XHJcblx0Y29uc3QgaXRlbTIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaTInKTtcclxuXHRjb25zdCBpdGVtMyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pMycpO1xyXG5cdGNvbnN0IGl0ZW00ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmk0Jyk7XHJcblx0Y29uc3QgaXRlbTUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaTUnKTtcclxuXHRjb25zdCBpdGVtNiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pNicpO1xyXG5cdGNvbnN0IGFycmF5ID0gW2JvZHksIGhlYWRlciwgaGVhZGVyTWVudVRoZW1lQnV0dG9uLCBpMlNraWxsc0l0ZW1Cb3gsIGZvb3RlciwgaXRlbTEsIGl0ZW0yLCBpdGVtMywgaXRlbTQsIGl0ZW01LCBpdGVtNl07XHJcblxyXG5cdGNvbnN0IHRvZ2dsZVRoZW1lID0gKCkgPT4ge1xyXG5cdFx0YXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG5cdFx0XHRpdGVtLmNsYXNzTGlzdC50b2dnbGUoJ2RhcmstbW9kZScpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0YnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0dG9nZ2xlVGhlbWUoKTtcclxuXHRcdGlmIChib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFyay1tb2RlJykpIHtcclxuXHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2lzRGFya01vZGUnLCB0cnVlKTtcclxuXHRcdFx0YnV0dG9uLnRleHRDb250ZW50ID0gJ9Ch0LLQtdGC0LvRi9C5INGA0LXQttC40LwnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YnV0dG9uLnRleHRDb250ZW50ID0gJ9Ci0ZHQvNC90YvQuSDRgNC10LbQuNC8JztcclxuXHRcdFx0bG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2lzRGFya01vZGUnLCBmYWxzZSk7XHJcblx0XHR9XHJcblx0XHRpc0RhcmtNb2RlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2lzRGFya01vZGUnKTtcclxuXHRcdGNvbnNvbGUubG9nKCd+IGlzRGFya01vZGUnLCBpc0RhcmtNb2RlKTtcclxuXHR9KTtcclxuXHJcblx0bGV0IGlzRGFya01vZGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaXNEYXJrTW9kZScpO1xyXG5cdGNvbnNvbGUubG9nKCd+IGlzRGFya01vZGUnLCBpc0RhcmtNb2RlKTtcclxuXHJcblx0aWYgKGlzRGFya01vZGUgPT09ICd0cnVlJykge1xyXG5cdFx0dG9nZ2xlVGhlbWUoKTtcclxuXHRcdGJ1dHRvbi50ZXh0Q29udGVudCA9ICfQodCy0LXRgtC70YvQuSDRgNC10LbQuNC8JztcclxuXHR9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjaGFuZ2VUaGVtZTtcclxuIiwiY29uc3Qgc3RpY2tNZW51ID0gKCkgPT4ge1xyXG5cdGxldCBsYXN0U2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG5cclxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xyXG5cdFx0Ly8gY29uc29sZS5sb2coJ2xhc3RTY3JvbGxUb3A6ICcsIGxhc3RTY3JvbGxUb3ApO1xyXG5cdFx0Ly8gY29uc29sZS5sb2coJ3dpbmRvdy5wYWdlWU9mZnNldDogJywgd2luZG93LnBhZ2VZT2Zmc2V0KTtcclxuXHJcblx0XHRpZiAod2luZG93LnBhZ2VZT2Zmc2V0IDwgbGFzdFNjcm9sbFRvcCkge1xyXG5cdFx0XHRjb25zb2xlLmxvZygn0J/QvtC60LDQt9GL0LLQsNC10Lwg0LzQtdC90Y4nKTtcclxuXHRcdH1cclxuXHRcdGxhc3RTY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzdGlja01lbnU7XHJcbiIsImNvbnN0IGFuaW1hdGUgPSBmdW5jdGlvbiAoeyB0aW1pbmcsIGRyYXcsIGR1cmF0aW9uIH0pIHtcclxuXHRsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGUodGltZSkge1xyXG5cdFx0Ly8gdGltZUZyYWN0aW9uINC40LfQvNC10L3Rj9C10YLRgdGPINC+0YIgMCDQtNC+IDFcclxuXHRcdGxldCB0aW1lRnJhY3Rpb24gPSAodGltZSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xyXG5cdFx0aWYgKHRpbWVGcmFjdGlvbiA+IDEpIHRpbWVGcmFjdGlvbiA9IDE7XHJcblxyXG5cdFx0Ly8g0LLRi9GH0LjRgdC70LXQvdC40LUg0YLQtdC60YPRidC10LPQviDRgdC+0YHRgtC+0Y/QvdC40Y8g0LDQvdC40LzQsNGG0LjQuFxyXG5cdFx0bGV0IHByb2dyZXNzID0gdGltaW5nKHRpbWVGcmFjdGlvbik7XHJcblxyXG5cdFx0ZHJhdyhwcm9ncmVzcyk7IC8vINC+0YLRgNC40YHQvtCy0LDRgtGMINC10ZFcclxuXHJcblx0XHRpZiAodGltZUZyYWN0aW9uIDwgMSkge1xyXG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxyXG5leHBvcnQgeyBhbmltYXRlIH07XHJcbiIsImltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuY29uc3Qgc2tpbGxzQW5pbWF0aW9uID0gKHNraWxsc0FycmF5LCB0aW1lKSA9PiB7XHJcblx0Y29uc3Qgc2tpbGxJdGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pMi1za2lsbHMtaXRlbScpO1xyXG5cdGNvbnN0IHNraWxsc0Jsb2NrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NraWxscycpO1xyXG5cdGxldCBpbmRleCA9IDA7XHJcblx0bGV0IGlzU2tpbGxzQW5pbWF0aW9uU2hvd24gPSBmYWxzZTtcclxuXHJcblx0Y29uc3QgZ2V0SXRlbVRleHQgPSAoaW5kZXgpID0+IHtcclxuXHRcdHNraWxsSXRlbXNbaW5kZXhdLnF1ZXJ5U2VsZWN0b3IoJy5za2lsbC12YWx1ZScpLnRleHRDb250ZW50ID0gc2tpbGxzQXJyYXlbaW5kZXhdLnZhbHVlICsgJyUnO1xyXG5cdFx0c2tpbGxJdGVtc1tpbmRleF0ucXVlcnlTZWxlY3RvcignLnNraWxsLW5hbWUnKS50ZXh0Q29udGVudCA9IHNraWxsc0FycmF5W2luZGV4XS5za2lsbDtcclxuXHRcdGluZGV4Kys7XHJcblx0XHRpZiAoaW5kZXggPCBza2lsbEl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0XHRhbmltYXRlSXRlbShpbmRleCwgdGltZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRjb25zdCBhbmltYXRlSXRlbSA9IChpbmRleCwgdGltZSkgPT4ge1xyXG5cdFx0c2tpbGxJdGVtc1tpbmRleF0uc3R5bGUub3BhY2l0eSA9ICcxJztcclxuXHRcdGFuaW1hdGUoe1xyXG5cdFx0XHRkdXJhdGlvbjogdGltZSxcclxuXHRcdFx0dGltaW5nKHRpbWVGcmFjdGlvbikge1xyXG5cdFx0XHRcdHJldHVybiB0aW1lRnJhY3Rpb247XHJcblx0XHRcdH0sXHJcblx0XHRcdGRyYXcocHJvZ3Jlc3MpIHtcclxuXHRcdFx0XHRza2lsbEl0ZW1zW2luZGV4XS5xdWVyeVNlbGVjdG9yKCcuc2tpbGwtbmFtZScpLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3MgKiBza2lsbHNBcnJheVtpbmRleF0udmFsdWV9JWA7XHJcblx0XHRcdFx0aWYgKHByb2dyZXNzID49IDEpIHtcclxuXHRcdFx0XHRcdGdldEl0ZW1UZXh0KGluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xyXG5cdFx0Y29uc3QgYmxvY2tZID0gc2tpbGxzQmxvY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xyXG5cdFx0Y29uc3QgcGFnZVkgPSB3aW5kb3cucGFnZVlPZmZzZXQgKyBza2lsbHNCbG9jay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XHJcblxyXG5cdFx0aWYgKGJsb2NrWSA8IHBhZ2VZICYmICFpc1NraWxsc0FuaW1hdGlvblNob3duKSB7XHJcblx0XHRcdGlzU2tpbGxzQW5pbWF0aW9uU2hvd24gPSB0cnVlO1xyXG5cdFx0XHRhbmltYXRlSXRlbShpbmRleCwgdGltZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IHNraWxsc0FuaW1hdGlvbjtcclxuIiwiaW1wb3J0IGNob29zZUFib3V0IGZyb20gJy4vbW9kdWxlcy9jaG9vc2VBYm91dCc7XHJcbmltcG9ydCBzY3JvbGxJbnRvVmlldyBmcm9tICcuL21vZHVsZXMvc2Nyb2xsSW50b1ZpZXcnO1xyXG5pbXBvcnQgY2hhbmdlVGhlbWUgZnJvbSAnLi9tb2R1bGVzL2NoYW5nZVRoZW1lJztcclxuaW1wb3J0IHN0aWNrTWVudSBmcm9tICcuL21vZHVsZXMvc3RpY2tNZW51JztcclxuaW1wb3J0IHNraWxsc0FuaW1hdGlvbiBmcm9tICcuL21vZHVsZXMvc2tpbGxzQW5pbWF0aW9uJztcclxuXHJcbmNob29zZUFib3V0KCk7XHJcbnNjcm9sbEludG9WaWV3KCk7XHJcbmNoYW5nZVRoZW1lKCk7XHJcbnN0aWNrTWVudSgpO1xyXG5za2lsbHNBbmltYXRpb24oXHJcblx0W1xyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ0hUTUwgJiBDU1MnLFxyXG5cdFx0XHR2YWx1ZTogNTAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ0pBVkFTQ1JJUFQnLFxyXG5cdFx0XHR2YWx1ZTogODAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ0dJVCcsXHJcblx0XHRcdHZhbHVlOiA0MCxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNraWxsOiAnV0VCUEFDSycsXHJcblx0XHRcdHZhbHVlOiA0MCxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNraWxsOiAnU0NTUy9TQVNTJyxcclxuXHRcdFx0dmFsdWU6IDIwLFxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2tpbGw6ICdCT09UU1RSQVAnLFxyXG5cdFx0XHR2YWx1ZTogMjAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ0dVTFAnLFxyXG5cdFx0XHR2YWx1ZTogMTAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ1BVRycsXHJcblx0XHRcdHZhbHVlOiAxMCxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNraWxsOiAnUEhPVE9TSE9QJyxcclxuXHRcdFx0dmFsdWU6IDgwLFxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2tpbGw6ICdGSUdNQScsXHJcblx0XHRcdHZhbHVlOiAyMCxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNraWxsOiAnUkVBQ1QnLFxyXG5cdFx0XHR2YWx1ZTogMTAsXHJcblx0XHR9LFxyXG5cdF0sXHJcblx0MTUwXHJcbik7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///89\n")}},__webpack_exports__={};__webpack_modules__[89]()})();