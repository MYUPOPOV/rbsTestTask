(()=>{"use strict";var __webpack_modules__={482:()=>{eval('\n;// CONCATENATED MODULE: ./modules/chooseAbout.js\nconst chooseAbout = () => {\r\n\tconst chooseBlock = document.querySelector(\'.i5-about-choose\');\r\n\tconst chooseBlockAll = document.querySelectorAll(\'.i5-about-choose-block\');\r\n\tconst aboutContentAll = document.querySelectorAll(\'.i5-about-content\');\r\n\r\n\tchooseBlock.addEventListener(\'click\', (e) => {\r\n\t\tif (e.target.closest(\'.i5-about-choose-block\')) {\r\n\t\t\tchooseBlockAll.forEach((item, index) => {\r\n\t\t\t\taboutContentAll[index].classList.add(\'hidden\');\r\n\t\t\t\tif (item === e.target.closest(\'.i5-about-choose-block\')) {\r\n\t\t\t\t\taboutContentAll[index].classList.toggle(\'hidden\');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/* harmony default export */ const modules_chooseAbout = (chooseAbout);\r\n\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/common.js\nconst checkBehavior = (behavior) => {\n    return behavior === undefined || behavior === "auto" || behavior === "instant" || behavior === "smooth";\n};\nfunction elementScrollXY(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\nconst failedExecute = (method, object, reason = "cannot convert to dictionary.") => `Failed to execute \'${method}\' on \'${object}\': ${reason}`;\nconst failedExecuteInvalidEnumValue = (method, object, value) => failedExecute(method, object, `The provided value \'${value}\' is not a valid enum value of type ScrollBehavior.`);\n/* eslint-disable */\nconst backupMethod = (proto, method, fallback) => {\n    var _a;\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n    if (!proto[backup] && proto[method] && !((_a = proto[method]) === null || _a === void 0 ? void 0 : _a.__isPolyfill)) {\n        proto[backup] = proto[method];\n    }\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\nconst isObject = (value) => {\n    const type = typeof value;\n    return value !== null && (type === "object" || type === "function");\n};\nconst isScrollBehaviorSupported = () => "scrollBehavior" in window.document.documentElement.style;\nconst markPolyfill = (method) => {\n    Object.defineProperty(method, "__isPolyfill", { value: true });\n};\nconst modifyPrototypes = (prop, func) => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nconst scrollingElement = (element) => element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n//# sourceMappingURL=common.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scroll-step.js\nconst ease = (k) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n/* eslint-disable */\nfunction now() {\n    var _a;\n    let fn;\n    if ((_a = window.performance) === null || _a === void 0 ? void 0 : _a.now) {\n        fn = () => window.performance.now();\n    }\n    else {\n        fn = () => window.Date.now();\n    }\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\nconst DURATION = 500;\nconst step = (context) => {\n    const currentTime = now();\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n    context.method(currentX, currentY);\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n//# sourceMappingURL=scroll-step.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scroll.js\n\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value) => {\n    if (!isFinite(value)) {\n        return 0;\n    }\n    return Number(value);\n};\nconst isConnected = (node) => {\n    var _a;\n    return ((_a = node.isConnected) !== null && _a !== void 0 ? _a : (!node.ownerDocument ||\n        // eslint-disable-next-line no-bitwise\n        !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1)));\n};\nconst scrollWithOptions = (element, options, config) => {\n    var _a, _b;\n    if (!isConnected(element)) {\n        return;\n    }\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n    const targetX = nonFinite((_a = options.left) !== null && _a !== void 0 ? _a : startX);\n    const targetY = nonFinite((_b = options.top) !== null && _b !== void 0 ? _b : startY);\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n    const fallback = backupMethod(HTMLElement.prototype, "scroll", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element), "scroll", fallback).bind(element);\n    if (options.behavior !== "smooth") {\n        method(targetX, targetY);\n        return;\n    }\n    const removeEventListener = () => {\n        window.removeEventListener("wheel", cancelScroll);\n        window.removeEventListener("touchmove", cancelScroll);\n    };\n    const context = Object.assign(Object.assign({}, config), { timeStamp: now(), startX,\n        startY,\n        targetX,\n        targetY, rafId: 0, method, callback: removeEventListener });\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n    window.addEventListener("wheel", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener("touchmove", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    step(context);\n};\nconst isWindow = (obj) => obj.window === obj;\nconst createScroll = (scrollName) => (target, scrollOptions, config) => {\n    const [element, scrollType] = isWindow(target)\n        ? [scrollingElement(target.document.documentElement), "Window"]\n        : [target, "Element"];\n    const options = scrollOptions !== null && scrollOptions !== void 0 ? scrollOptions : {};\n    if (!isObject(options)) {\n        throw new TypeError(failedExecute(scrollName, scrollType));\n    }\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n    }\n    if (scrollName === "scrollBy") {\n        options.left = nonFinite(options.left) + element.scrollLeft;\n        options.top = nonFinite(options.top) + element.scrollTop;\n    }\n    scrollWithOptions(element, options, config);\n};\nconst scroll_scroll = /* #__PURE__ */ createScroll("scroll");\nconst scrollTo = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll("scrollTo")));\nconst scrollBy = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll("scrollBy")));\nconst elementScroll = scroll_scroll;\nconst elementScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst elementScrollBy = (/* unused pure expression or super */ null && (scrollBy));\nconst windowScroll = (/* unused pure expression or super */ null && (scroll_scroll));\nconst windowScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst windowScrollBy = (/* unused pure expression or super */ null && (scrollBy));\n//# sourceMappingURL=scroll.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scrollIntoView.js\n/* eslint-disable no-bitwise */\n\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode) => {\n    switch (writingMode) {\n        case "horizontal-tb":\n        case "lr":\n        case "lr-tb":\n        case "rl":\n        case "rl-tb":\n            return 0 /* HorizontalTb */;\n        case "vertical-rl":\n        case "tb":\n        case "tb-rl":\n            return 1 /* VerticalRl */;\n        case "vertical-lr":\n        case "tb-lr":\n            return 2 /* VerticalLr */;\n        case "sideways-rl":\n            return 3 /* SidewaysRl */;\n        case "sideways-lr":\n            return 4 /* SidewaysLr */;\n    }\n    return 0 /* HorizontalTb */;\n};\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= 2 /* ReverseVertical */;\n    }\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case 0 /* HorizontalTb */:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case 1 /* VerticalRl */:\n        case 3 /* SidewaysRl */:\n            //  reverse horizontal\n            layout ^= 1 /* ReverseHorizontal */;\n            break;\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case 4 /* SidewaysLr */:\n            // reverse vertical\n            layout ^= 2 /* ReverseVertical */;\n            break;\n    }\n    return [layout, hPos, vPos];\n};\nconst isXReversed = (computedStyle) => {\n    const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== "rtl", undefined, undefined)[0];\n    return (layout & 1) === 1;\n};\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || "start", options.inline || "nearest");\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case "center":\n                return 1 /* CenterAlways */;\n            case "nearest":\n                return 0 /* ToEdgeIfNeeded */;\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === "start") === !reverse ? 2 /* LeftOrTop */ : 3 /* RightOrBottom */;\n            }\n        }\n    });\n};\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is "nearest"\n * Interesting fact: "nearest" works similarily to "if-needed", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n    if (align !== 0 /* ToEdgeIfNeeded */) {\n        return align;\n    }\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n        return null;\n    }\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n        return 2 /* LeftOrTop */;\n    }\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n        return 3 /* RightOrBottom */;\n    }\n    return null;\n};\nconst canOverflow = (overflow) => {\n    return overflow !== "visible" && overflow !== "clip";\n};\nconst getFrameElement = (element) => {\n    var _a;\n    try {\n        return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n    }\n    catch (_b) {\n        return null;\n    }\n};\nconst isScrollable = (element, computedStyle) => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element));\n    }\n    return false;\n};\nconst parentElement = (element) => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return pNode.host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n    return pElement;\n};\nconst clamp = (value, min, max) => {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n};\nconst getSupportedScrollMarginProperty = (ownerDocument) => {\n    // Webkit uses "scroll-snap-margin" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return ["scroll-margin", "scroll-snap-margin"].filter((property) => property in ownerDocument.documentElement.style)[0];\n};\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n    const scrollMarginValue = (edge) => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n    return [\n        top - scrollMarginValue("top"),\n        right + scrollMarginValue("right"),\n        bottom + scrollMarginValue("bottom"),\n        left - scrollMarginValue("left"),\n    ];\n};\nconst calcAlignEdge = (align, start, end) => {\n    switch (align) {\n        case 1 /* CenterAlways */:\n            return (start + end) / 2;\n        case 3 /* RightOrBottom */:\n            return end;\n        case 2 /* LeftOrTop */:\n        case 0 /* ToEdgeIfNeeded */:\n            return start;\n    }\n};\nconst getFrameViewport = (frame, frameRect) => {\n    var _a, _b, _c;\n    const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n    const [x, y, width, height] = frame === scrollingElement(frame)\n        ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight]\n        : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n    return [top, right, bottom, left];\n};\nconst computeScrollIntoView = (element, options) => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions = [];\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n    if (!ownerWindow) {\n        return actions;\n    }\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== "rtl";\n    const writingMode = normalizeWritingMode(computedStyle.writingMode ||\n        computedStyle.getPropertyValue("-webkit-writing-mode") ||\n        computedStyle.getPropertyValue("-ms-writing-mode"));\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n        if (frameStyle.position === "fixed") {\n            break;\n        }\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n        const frameRect = frame.getBoundingClientRect();\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n        const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n    return actions;\n};\nconst scrollIntoView = (element, scrollIntoViewOptions, config) => {\n    const options = scrollIntoViewOptions || {};\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue("scrollIntoView", "Element", options.behavior));\n    }\n    const actions = computeScrollIntoView(element, options);\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\nconst elementScrollIntoView = scrollIntoView;\n//# sourceMappingURL=scrollIntoView.js.map\n;// CONCATENATED MODULE: ./modules/menuButtons.js\n\r\n\r\nconst menuButtons = () => {\r\n\tconst headerMenu = document.querySelector(\'.header-menu\');\r\n\tconsole.log(\'~ headerMenu\', headerMenu);\r\n\r\n\tconst scrollUp = function (object) {\r\n\t\telementScrollIntoView(object, { behavior: \'smooth\', block: \'center\', inline: \'center\' });\r\n\t};\r\n\r\n\theaderMenu.addEventListener(\'click\', (e) => {\r\n\t\t// console.log(e.target);\r\n\r\n\t\tif (e.target.classList.contains(\'header-menu-item\')) {\r\n\t\t\tconst itemLink = document.getElementById(e.target.getAttribute(\'href\').substring(1));\r\n\t\t\tscrollUp.bind(itemLink)(itemLink);\r\n\t\t}\r\n\t});\r\n\r\n\tconsole.log(\'scrollIntoView\');\r\n};\r\n\r\n/* harmony default export */ const modules_menuButtons = (menuButtons);\r\n\n;// CONCATENATED MODULE: ./modules/skillsAnimation.js\nconst skillsAnimation = (skillsArray) => {\r\n\r\n\r\n\r\n\r\n};\r\n\r\n/* harmony default export */ const modules_skillsAnimation = (skillsAnimation);\r\n\n;// CONCATENATED MODULE: ./index.js\n\r\n\r\n\r\n\r\nmodules_chooseAbout();\r\nmodules_menuButtons();\r\nmodules_skillsAnimation([\r\n\t{\r\n\t\tskill: \'HTML & CSS\',\r\n\t\tvalue: 50,\r\n\t},\r\n\t{\r\n\t\tskill: \'JavaSript\',\r\n\t\tvalue: 80,\r\n\t},\r\n\t{\r\n\t\tskill: \'GIT\',\r\n\t\tvalue: 40,\r\n\t},\r\n\t{\r\n\t\tskill: \'WEBPACK\',\r\n\t\tvalue: 40,\r\n\t},\r\n\t{\r\n\t\tskill: \'SCSS/SASS\',\r\n\t\tvalue: 20,\r\n\t},\r\n\t{\r\n\t\tskill: \'BOOTSTRAP\',\r\n\t\tvalue: 20,\r\n\t},\r\n\t{\r\n\t\tskill: \'GULP\',\r\n\t\tvalue: 10,\r\n\t},\r\n\t{\r\n\t\tskill: \'PUG\',\r\n\t\tvalue: 10,\r\n\t},\r\n\t{\r\n\t\tskill: \'PHOTOSHOP\',\r\n\t\tvalue: 80,\r\n\t},\r\n\t{\r\n\t\tskill: \'FIGMA\',\r\n\t\tvalue: 20,\r\n\t},\r\n\t{\r\n\t\tskill: \'REACT\',\r\n\t\tvalue: 10,\r\n\t},\r\n]);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSwwREFBZSxXQUFXLEVBQUM7OztBQ2pCcEI7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTywwR0FBMEcsT0FBTyxRQUFRLE9BQU8sS0FBSyxPQUFPO0FBQzVJLHNIQUFzSCxNQUFNO0FBQ25JO0FBQ087QUFDUDtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0M7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDOztBQ25Dc0o7QUFDekc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxrQ0FBa0MsZUFBZTtBQUNsRixtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWEsV0FBVyxHQUFHO0FBQzdFO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQiw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLFNBQVMsYUFBYTtBQUN0Qiw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxhQUFNO0FBQ1osaUNBQWlDLHdFQUF3QjtBQUN6RCxpQ0FBaUMsd0VBQXdCO0FBQ3pELHNCQUFzQixhQUFNO0FBQzVCLHdCQUF3Qix3REFBUTtBQUNoQyx3QkFBd0Isd0RBQVE7QUFDaEMscUJBQXFCLDZEQUFNO0FBQzNCLHVCQUF1Qix3REFBUTtBQUMvQix1QkFBdUIsd0RBQVE7QUFDdEMsa0M7O0FDbEZBO0FBQzZGO0FBQ2pEO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLFlBQVk7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGVBQWUsR0FBRyxLQUFLO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwRkFBMEY7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxTQUFTLGFBQWE7QUFDdEIsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckIsS0FBSztBQUNMO0FBQ087QUFDUCwwQzs7QUMxWWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscUJBQXFCLFdBQVcsdURBQXVEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUFlLFdBQVcsRUFBQzs7O0FDdEIzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUFlLGVBQWUsRUFBQzs7O0FDUGlCO0FBQ0E7QUFDUTtBQUN4RDtBQUNBLG1CQUFXO0FBQ1gsbUJBQVc7QUFDWCx1QkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tb2R1bGVzL2Nob29zZUFib3V0LmpzPzg3OGUiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL2NvbW1vbi5qcz84NWM2Iiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2VhbWxlc3Mtc2Nyb2xsLXBvbHlmaWxsL2xpYi9zY3JvbGwtc3RlcC5qcz83NGIwIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2VhbWxlc3Mtc2Nyb2xsLXBvbHlmaWxsL2xpYi9zY3JvbGwuanM/N2Q2MyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbC9saWIvc2Nyb2xsSW50b1ZpZXcuanM/YzQ0YSIsIndlYnBhY2s6Ly8vLi9tb2R1bGVzL21lbnVCdXR0b25zLmpzPzdkZWEiLCJ3ZWJwYWNrOi8vLy4vbW9kdWxlcy9za2lsbHNBbmltYXRpb24uanM/MmM2ZiIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcz80MWY1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNob29zZUFib3V0ID0gKCkgPT4ge1xyXG5cdGNvbnN0IGNob29zZUJsb2NrID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmk1LWFib3V0LWNob29zZScpO1xyXG5cdGNvbnN0IGNob29zZUJsb2NrQWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmk1LWFib3V0LWNob29zZS1ibG9jaycpO1xyXG5cdGNvbnN0IGFib3V0Q29udGVudEFsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pNS1hYm91dC1jb250ZW50Jyk7XHJcblxyXG5cdGNob29zZUJsb2NrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuXHRcdGlmIChlLnRhcmdldC5jbG9zZXN0KCcuaTUtYWJvdXQtY2hvb3NlLWJsb2NrJykpIHtcclxuXHRcdFx0Y2hvb3NlQmxvY2tBbGwuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuXHRcdFx0XHRhYm91dENvbnRlbnRBbGxbaW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG5cdFx0XHRcdGlmIChpdGVtID09PSBlLnRhcmdldC5jbG9zZXN0KCcuaTUtYWJvdXQtY2hvb3NlLWJsb2NrJykpIHtcclxuXHRcdFx0XHRcdGFib3V0Q29udGVudEFsbFtpbmRleF0uY2xhc3NMaXN0LnRvZ2dsZSgnaGlkZGVuJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9KTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNob29zZUFib3V0O1xyXG4iLCJleHBvcnQgY29uc3QgY2hlY2tCZWhhdmlvciA9IChiZWhhdmlvcikgPT4ge1xuICAgIHJldHVybiBiZWhhdmlvciA9PT0gdW5kZWZpbmVkIHx8IGJlaGF2aW9yID09PSBcImF1dG9cIiB8fCBiZWhhdmlvciA9PT0gXCJpbnN0YW50XCIgfHwgYmVoYXZpb3IgPT09IFwic21vb3RoXCI7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRTY3JvbGxYWSh4LCB5KSB7XG4gICAgdGhpcy5zY3JvbGxMZWZ0ID0geDtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHk7XG59XG5leHBvcnQgY29uc3QgZmFpbGVkRXhlY3V0ZSA9IChtZXRob2QsIG9iamVjdCwgcmVhc29uID0gXCJjYW5ub3QgY29udmVydCB0byBkaWN0aW9uYXJ5LlwiKSA9PiBgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bWV0aG9kfScgb24gJyR7b2JqZWN0fSc6ICR7cmVhc29ufWA7XG5leHBvcnQgY29uc3QgZmFpbGVkRXhlY3V0ZUludmFsaWRFbnVtVmFsdWUgPSAobWV0aG9kLCBvYmplY3QsIHZhbHVlKSA9PiBmYWlsZWRFeGVjdXRlKG1ldGhvZCwgb2JqZWN0LCBgVGhlIHByb3ZpZGVkIHZhbHVlICcke3ZhbHVlfScgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBvZiB0eXBlIFNjcm9sbEJlaGF2aW9yLmApO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBjb25zdCBiYWNrdXBNZXRob2QgPSAocHJvdG8sIG1ldGhvZCwgZmFsbGJhY2spID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYmFja3VwID0gYF9fU0VBTUxFU1MuQkFDS1VQJCR7bWV0aG9kfWA7XG4gICAgaWYgKCFwcm90b1tiYWNrdXBdICYmIHByb3RvW21ldGhvZF0gJiYgISgoX2EgPSBwcm90b1ttZXRob2RdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX19pc1BvbHlmaWxsKSkge1xuICAgICAgICBwcm90b1tiYWNrdXBdID0gcHJvdG9bbWV0aG9kXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3RvW2JhY2t1cF0gfHwgZmFsbGJhY2s7XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgKHR5cGUgPT09IFwib2JqZWN0XCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiKTtcbn07XG5leHBvcnQgY29uc3QgaXNTY3JvbGxCZWhhdmlvclN1cHBvcnRlZCA9ICgpID0+IFwic2Nyb2xsQmVoYXZpb3JcIiBpbiB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuZXhwb3J0IGNvbnN0IG1hcmtQb2x5ZmlsbCA9IChtZXRob2QpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcIl9faXNQb2x5ZmlsbFwiLCB7IHZhbHVlOiB0cnVlIH0pO1xufTtcbmV4cG9ydCBjb25zdCBtb2RpZnlQcm90b3R5cGVzID0gKHByb3AsIGZ1bmMpID0+IHtcbiAgICBtYXJrUG9seWZpbGwoZnVuYyk7XG4gICAgW0hUTUxFbGVtZW50LnByb3RvdHlwZSwgU1ZHRWxlbWVudC5wcm90b3R5cGUsIEVsZW1lbnQucHJvdG90eXBlXS5mb3JFYWNoKChwcm90b3R5cGUpID0+IHtcbiAgICAgICAgYmFja3VwTWV0aG9kKHByb3RvdHlwZSwgcHJvcCk7XG4gICAgICAgIHByb3RvdHlwZVtwcm9wXSA9IGZ1bmM7XG4gICAgfSk7XG59O1xuLyoqXG4gKiAtIE9uIENocm9tZSBhbmQgRmlyZWZveCwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB3aWxsIHJldHVybiB0aGUgPGh0bWw+IGVsZW1lbnQuXG4gKiAtIFNhZmFyaSwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB3aWxsIHJldHVybiB0aGUgPGJvZHk+IGVsZW1lbnQuXG4gKiAtIE9uIEVkZ2UsIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgd2lsbCByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LlxuICogLSBJRTExIGRvZXMgbm90IHN1cHBvcnQgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCwgYnV0IHlvdSBjYW4gYXNzdW1lIGl0cyA8aHRtbD4uXG4gKi9cbmV4cG9ydCBjb25zdCBzY3JvbGxpbmdFbGVtZW50ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiY29uc3QgZWFzZSA9IChrKSA9PiB7XG4gICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGZuO1xuICAgIGlmICgoX2EgPSB3aW5kb3cucGVyZm9ybWFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub3cpIHtcbiAgICAgICAgZm4gPSAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbiA9ICgpID0+IHdpbmRvdy5EYXRlLm5vdygpO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbm93ID0gZm47XG4gICAgcmV0dXJuIGZuKCk7XG59XG4vKiBlc2xpbnQtZW5hYmxlICovXG5jb25zdCBEVVJBVElPTiA9IDUwMDtcbmV4cG9ydCBjb25zdCBzdGVwID0gKGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSAoY3VycmVudFRpbWUgLSBjb250ZXh0LnRpbWVTdGFtcCkgLyAoY29udGV4dC5kdXJhdGlvbiB8fCBEVVJBVElPTik7XG4gICAgaWYgKGVsYXBzZWQgPiAxKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kKGNvbnRleHQudGFyZ2V0WCwgY29udGV4dC50YXJnZXRZKTtcbiAgICAgICAgY29udGV4dC5jYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gKGNvbnRleHQudGltaW5nRnVuYyB8fCBlYXNlKShlbGFwc2VkKTtcbiAgICBjb25zdCBjdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQudGFyZ2V0WCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xuICAgIGNvbnN0IGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC50YXJnZXRZIC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG4gICAgY29udGV4dC5tZXRob2QoY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICBjb250ZXh0LnJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHN0ZXAoY29udGV4dCk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsLXN0ZXAuanMubWFwIiwiaW1wb3J0IHsgYmFja3VwTWV0aG9kLCBjaGVja0JlaGF2aW9yLCBlbGVtZW50U2Nyb2xsWFksIGZhaWxlZEV4ZWN1dGUsIGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlLCBpc09iamVjdCwgc2Nyb2xsaW5nRWxlbWVudCwgfSBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCB7IG5vdywgc3RlcCB9IGZyb20gXCIuL3Njcm9sbC1zdGVwLmpzXCI7XG4vLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20tdmlldy8jbm9ybWFsaXplLW5vbi1maW5pdGUtdmFsdWVzXG5jb25zdCBub25GaW5pdGUgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG59O1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobm9kZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IG5vZGUuaXNDb25uZWN0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICghbm9kZS5vd25lckRvY3VtZW50IHx8XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICEobm9kZS5vd25lckRvY3VtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgLyoqIERPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRCAqLyAxKSkpO1xufTtcbmNvbnN0IHNjcm9sbFdpdGhPcHRpb25zID0gKGVsZW1lbnQsIG9wdGlvbnMsIGNvbmZpZykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0WCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBzdGFydFkgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCB0YXJnZXRYID0gbm9uRmluaXRlKChfYSA9IG9wdGlvbnMubGVmdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3RhcnRYKTtcbiAgICBjb25zdCB0YXJnZXRZID0gbm9uRmluaXRlKChfYiA9IG9wdGlvbnMudG9wKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzdGFydFkpO1xuICAgIGlmICh0YXJnZXRYID09PSBzdGFydFggJiYgdGFyZ2V0WSA9PT0gc3RhcnRZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmFsbGJhY2sgPSBiYWNrdXBNZXRob2QoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBcInNjcm9sbFwiLCBlbGVtZW50U2Nyb2xsWFkpO1xuICAgIGNvbnN0IG1ldGhvZCA9IGJhY2t1cE1ldGhvZChPYmplY3QuZ2V0UHJvdG90eXBlT2YoZWxlbWVudCksIFwic2Nyb2xsXCIsIGZhbGxiYWNrKS5iaW5kKGVsZW1lbnQpO1xuICAgIGlmIChvcHRpb25zLmJlaGF2aW9yICE9PSBcInNtb290aFwiKSB7XG4gICAgICAgIG1ldGhvZCh0YXJnZXRYLCB0YXJnZXRZKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGNhbmNlbFNjcm9sbCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGNhbmNlbFNjcm9sbCk7XG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IHRpbWVTdGFtcDogbm93KCksIHN0YXJ0WCxcbiAgICAgICAgc3RhcnRZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLCByYWZJZDogMCwgbWV0aG9kLCBjYWxsYmFjazogcmVtb3ZlRXZlbnRMaXN0ZW5lciB9KTtcbiAgICBjb25zdCBjYW5jZWxTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShjb250ZXh0LnJhZklkKTtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBjYW5jZWxTY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBjYW5jZWxTY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBzdGVwKGNvbnRleHQpO1xufTtcbmNvbnN0IGlzV2luZG93ID0gKG9iaikgPT4gb2JqLndpbmRvdyA9PT0gb2JqO1xuY29uc3QgY3JlYXRlU2Nyb2xsID0gKHNjcm9sbE5hbWUpID0+ICh0YXJnZXQsIHNjcm9sbE9wdGlvbnMsIGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IFtlbGVtZW50LCBzY3JvbGxUeXBlXSA9IGlzV2luZG93KHRhcmdldClcbiAgICAgICAgPyBbc2Nyb2xsaW5nRWxlbWVudCh0YXJnZXQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSwgXCJXaW5kb3dcIl1cbiAgICAgICAgOiBbdGFyZ2V0LCBcIkVsZW1lbnRcIl07XG4gICAgY29uc3Qgb3B0aW9ucyA9IHNjcm9sbE9wdGlvbnMgIT09IG51bGwgJiYgc2Nyb2xsT3B0aW9ucyAhPT0gdm9pZCAwID8gc2Nyb2xsT3B0aW9ucyA6IHt9O1xuICAgIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmYWlsZWRFeGVjdXRlKHNjcm9sbE5hbWUsIHNjcm9sbFR5cGUpKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja0JlaGF2aW9yKG9wdGlvbnMuYmVoYXZpb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZmFpbGVkRXhlY3V0ZUludmFsaWRFbnVtVmFsdWUoc2Nyb2xsTmFtZSwgc2Nyb2xsVHlwZSwgb3B0aW9ucy5iZWhhdmlvcikpO1xuICAgIH1cbiAgICBpZiAoc2Nyb2xsTmFtZSA9PT0gXCJzY3JvbGxCeVwiKSB7XG4gICAgICAgIG9wdGlvbnMubGVmdCA9IG5vbkZpbml0ZShvcHRpb25zLmxlZnQpICsgZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICBvcHRpb25zLnRvcCA9IG5vbkZpbml0ZShvcHRpb25zLnRvcCkgKyBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICB9XG4gICAgc2Nyb2xsV2l0aE9wdGlvbnMoZWxlbWVudCwgb3B0aW9ucywgY29uZmlnKTtcbn07XG5leHBvcnQgY29uc3Qgc2Nyb2xsID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVNjcm9sbChcInNjcm9sbFwiKTtcbmV4cG9ydCBjb25zdCBzY3JvbGxUbyA9IC8qICNfX1BVUkVfXyAqLyBjcmVhdGVTY3JvbGwoXCJzY3JvbGxUb1wiKTtcbmV4cG9ydCBjb25zdCBzY3JvbGxCeSA9IC8qICNfX1BVUkVfXyAqLyBjcmVhdGVTY3JvbGwoXCJzY3JvbGxCeVwiKTtcbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsID0gc2Nyb2xsO1xuZXhwb3J0IGNvbnN0IGVsZW1lbnRTY3JvbGxUbyA9IHNjcm9sbFRvO1xuZXhwb3J0IGNvbnN0IGVsZW1lbnRTY3JvbGxCeSA9IHNjcm9sbEJ5O1xuZXhwb3J0IGNvbnN0IHdpbmRvd1Njcm9sbCA9IHNjcm9sbDtcbmV4cG9ydCBjb25zdCB3aW5kb3dTY3JvbGxUbyA9IHNjcm9sbFRvO1xuZXhwb3J0IGNvbnN0IHdpbmRvd1Njcm9sbEJ5ID0gc2Nyb2xsQnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JvbGwuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuaW1wb3J0IHsgY2hlY2tCZWhhdmlvciwgZmFpbGVkRXhlY3V0ZUludmFsaWRFbnVtVmFsdWUsIHNjcm9sbGluZ0VsZW1lbnQgfSBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCB7IGVsZW1lbnRTY3JvbGwgfSBmcm9tIFwiLi9zY3JvbGwuanNcIjtcbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtd3JpdGluZy1tb2Rlcy00LyNibG9jay1mbG93XG5jb25zdCBub3JtYWxpemVXcml0aW5nTW9kZSA9ICh3cml0aW5nTW9kZSkgPT4ge1xuICAgIHN3aXRjaCAod3JpdGluZ01vZGUpIHtcbiAgICAgICAgY2FzZSBcImhvcml6b250YWwtdGJcIjpcbiAgICAgICAgY2FzZSBcImxyXCI6XG4gICAgICAgIGNhc2UgXCJsci10YlwiOlxuICAgICAgICBjYXNlIFwicmxcIjpcbiAgICAgICAgY2FzZSBcInJsLXRiXCI6XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBIb3Jpem9udGFsVGIgKi87XG4gICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbC1ybFwiOlxuICAgICAgICBjYXNlIFwidGJcIjpcbiAgICAgICAgY2FzZSBcInRiLXJsXCI6XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBWZXJ0aWNhbFJsICovO1xuICAgICAgICBjYXNlIFwidmVydGljYWwtbHJcIjpcbiAgICAgICAgY2FzZSBcInRiLWxyXCI6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBWZXJ0aWNhbExyICovO1xuICAgICAgICBjYXNlIFwic2lkZXdheXMtcmxcIjpcbiAgICAgICAgICAgIHJldHVybiAzIC8qIFNpZGV3YXlzUmwgKi87XG4gICAgICAgIGNhc2UgXCJzaWRld2F5cy1sclwiOlxuICAgICAgICAgICAgcmV0dXJuIDQgLyogU2lkZXdheXNMciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogSG9yaXpvbnRhbFRiICovO1xufTtcbmNvbnN0IGNhbGNQaHlzaWNhbEF4aXMgPSAod3JpdGluZ01vZGUsIGlzTFRSLCBoUG9zLCB2UG9zKSA9PiB7XG4gICAgLyoqICAwYnt2ZXJ0aWNhbH17aG9yaXpvbnRhbH0gIDA6IG5vcm1hbCwgMTogcmV2ZXJzZSAqL1xuICAgIGxldCBsYXlvdXQgPSAwYjAwO1xuICAgIC8qKlxuICAgICAqIFdyaXRpbmdNb2RlLlZlcnRpY2FsTHI6IOKGk+KGklxuICAgICAqIHwgMSB8IDQgfCAgIHxcbiAgICAgKiB8IDIgfCA1IHwgICB8XG4gICAgICogfCAzIHwgICB8ICAgfFxuICAgICAqXG4gICAgICogUlRMOiDihpHihpJcbiAgICAgKiB8IDMgfCAgIHwgICB8XG4gICAgICogfCAyIHwgNSB8ICAgfFxuICAgICAqIHwgMSB8IDQgfCAgIHxcbiAgICAgKi9cbiAgICBpZiAoIWlzTFRSKSB7XG4gICAgICAgIGxheW91dCBePSAyIC8qIFJldmVyc2VWZXJ0aWNhbCAqLztcbiAgICB9XG4gICAgc3dpdGNoICh3cml0aW5nTW9kZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICog4oaT4oaSXG4gICAgICAgICAqIHwgMSB8IDIgfCAzIHxcbiAgICAgICAgICogfCA0IHwgNSB8ICAgfFxuICAgICAgICAgKiB8ICAgfCAgIHwgICB8XG4gICAgICAgICAqXG4gICAgICAgICAqIFJUTDog4oaT4oaQXG4gICAgICAgICAqIHwgMyB8IDIgfCAxIHxcbiAgICAgICAgICogfCAgIHwgNSB8IDQgfFxuICAgICAgICAgKiB8ICAgfCAgIHwgICB8XG4gICAgICAgICAqL1xuICAgICAgICBjYXNlIDAgLyogSG9yaXpvbnRhbFRiICovOlxuICAgICAgICAgICAgLy8gc3dhcCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICAgICAgICAgICAgbGF5b3V0ID0gKGxheW91dCA+PiAxKSB8ICgobGF5b3V0ICYgMSkgPDwgMSk7XG4gICAgICAgICAgICBbaFBvcywgdlBvc10gPSBbdlBvcywgaFBvc107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOKGk+KGkFxuICAgICAgICAgKiB8ICAgfCA0IHwgMSB8XG4gICAgICAgICAqIHwgICB8IDUgfCAyIHxcbiAgICAgICAgICogfCAgIHwgICB8IDMgfFxuICAgICAgICAgKlxuICAgICAgICAgKiBSVEw6IOKGkeKGkFxuICAgICAgICAgKiB8ICAgfCAgIHwgMyB8XG4gICAgICAgICAqIHwgICB8IDUgfCAyIHxcbiAgICAgICAgICogfCAgIHwgNCB8IDEgfFxuICAgICAgICAgKi9cbiAgICAgICAgY2FzZSAxIC8qIFZlcnRpY2FsUmwgKi86XG4gICAgICAgIGNhc2UgMyAvKiBTaWRld2F5c1JsICovOlxuICAgICAgICAgICAgLy8gIHJldmVyc2UgaG9yaXpvbnRhbFxuICAgICAgICAgICAgbGF5b3V0IF49IDEgLyogUmV2ZXJzZUhvcml6b250YWwgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOKGkeKGklxuICAgICAgICAgKiB8IDMgfCAgIHwgICB8XG4gICAgICAgICAqIHwgMiB8IDUgfCAgIHxcbiAgICAgICAgICogfCAxIHwgNCB8ICAgfFxuICAgICAgICAgKlxuICAgICAgICAgKiBSVEw6IOKGk+KGklxuICAgICAgICAgKiB8IDEgfCA0IHwgICB8XG4gICAgICAgICAqIHwgMiB8IDUgfCAgIHxcbiAgICAgICAgICogfCAzIHwgICB8ICAgfFxuICAgICAgICAgKi9cbiAgICAgICAgY2FzZSA0IC8qIFNpZGV3YXlzTHIgKi86XG4gICAgICAgICAgICAvLyByZXZlcnNlIHZlcnRpY2FsXG4gICAgICAgICAgICBsYXlvdXQgXj0gMiAvKiBSZXZlcnNlVmVydGljYWwgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFtsYXlvdXQsIGhQb3MsIHZQb3NdO1xufTtcbmNvbnN0IGlzWFJldmVyc2VkID0gKGNvbXB1dGVkU3R5bGUpID0+IHtcbiAgICBjb25zdCBsYXlvdXQgPSBjYWxjUGh5c2ljYWxBeGlzKG5vcm1hbGl6ZVdyaXRpbmdNb2RlKGNvbXB1dGVkU3R5bGUud3JpdGluZ01vZGUpLCBjb21wdXRlZFN0eWxlLmRpcmVjdGlvbiAhPT0gXCJydGxcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpWzBdO1xuICAgIHJldHVybiAobGF5b3V0ICYgMSkgPT09IDE7XG59O1xuLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46dGhpcmRfcGFydHkvYmxpbmsvcmVuZGVyZXIvY29yZS9kb20vZWxlbWVudC5jYztsPTEwOTctMTE4OTtkcmM9NmE3NTMzZDRhMWU5ZjIzNzIyMjNhOWQ5MTJhOWU1M2E2ZmEzNWFlMFxuY29uc3QgdG9QaHlzaWNhbEFsaWdubWVudCA9IChvcHRpb25zLCB3cml0aW5nTW9kZSwgaXNMVFIpID0+IHtcbiAgICBjb25zdCBbbGF5b3V0LCBoUG9zLCB2UG9zXSA9IGNhbGNQaHlzaWNhbEF4aXMod3JpdGluZ01vZGUsIGlzTFRSLCBvcHRpb25zLmJsb2NrIHx8IFwic3RhcnRcIiwgb3B0aW9ucy5pbmxpbmUgfHwgXCJuZWFyZXN0XCIpO1xuICAgIHJldHVybiBbaFBvcywgdlBvc10ubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIENlbnRlckFsd2F5cyAqLztcbiAgICAgICAgICAgIGNhc2UgXCJuZWFyZXN0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogVG9FZGdlSWZOZWVkZWQgKi87XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJzZSA9IChsYXlvdXQgPj4gaW5kZXgpICYgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlID09PSBcInN0YXJ0XCIpID09PSAhcmV2ZXJzZSA/IDIgLyogTGVmdE9yVG9wICovIDogMyAvKiBSaWdodE9yQm90dG9tICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuLy8gY29kZSBmcm9tIHN0aXBzYW4vY29tcHV0ZS1zY3JvbGwtaW50by12aWV3XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3RpcHNhbi9jb21wdXRlLXNjcm9sbC1pbnRvLXZpZXcvYmxvYi81Mzk2YzZiNzhhZjVkMGJiY2UxMWE3YzRlOTNjYzMxNDY1NDZmY2QzL3NyYy9pbmRleC50c1xuLyoqXG4gKiBGaW5kIG91dCB3aGljaCBlZGdlIHRvIGFsaWduIGFnYWluc3Qgd2hlbiBsb2dpY2FsIHNjcm9sbCBwb3NpdGlvbiBpcyBcIm5lYXJlc3RcIlxuICogSW50ZXJlc3RpbmcgZmFjdDogXCJuZWFyZXN0XCIgd29ya3Mgc2ltaWxhcmlseSB0byBcImlmLW5lZWRlZFwiLCBpZiB0aGUgZWxlbWVudCBpcyBmdWxseSB2aXNpYmxlIGl0IHdpbGwgbm90IHNjcm9sbCBpdFxuICpcbiAqIExlZ2VuZHM6XG4gKiDilIzilIDilIDilIDilIDilIDilIDilIDilIDilJAg4pSPIOKUgSDilIEg4pSBIOKUk1xuICog4pSCIHRhcmdldCDilIIgICBmcmFtZVxuICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUlyDilIEg4pSBIOKUgSDilJtcbiAqL1xuY29uc3QgbWFwTmVhcmVzdCA9IChhbGlnbiwgc2Nyb2xsaW5nRWRnZVN0YXJ0LCBzY3JvbGxpbmdFZGdlRW5kLCBzY3JvbGxpbmdTaXplLCBlbGVtZW50RWRnZVN0YXJ0LCBlbGVtZW50RWRnZUVuZCwgZWxlbWVudFNpemUpID0+IHtcbiAgICBpZiAoYWxpZ24gIT09IDAgLyogVG9FZGdlSWZOZWVkZWQgKi8pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQSBhbmQgZWxlbWVudCBlZGdlIEIgYXJlIGJvdGggb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQSBhbmQgc2Nyb2xsaW5nIGJveCBlZGdlIEJcbiAgICAgKlxuICAgICAqICAgICAgICAgIOKUjOKUgOKUgOKUkFxuICAgICAqICAgICAgICDilI/ilIHilILilIHilIHilILilIHilJNcbiAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilIMg4pSCICDilIIg4pSDICAgICAgICBkbyBub3RoaW5nXG4gICAgICogICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbXG4gICAgICogICAgICAgICAg4pSU4pSA4pSA4pSYXG4gICAgICpcbiAgICAgKiAgSWYgZWxlbWVudCBlZGdlIEMgYW5kIGVsZW1lbnQgZWRnZSBEIGFyZSBib3RoIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEMgYW5kIHNjcm9sbGluZyBib3ggZWRnZSBEXG4gICAgICpcbiAgICAgKiAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICogICDilILilIMgICAgICAgICDilIPilIIgICAgICAgIGRvIG5vdGhpbmdcbiAgICAgKiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgICAqICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICovXG4gICAgaWYgKChlbGVtZW50RWRnZVN0YXJ0IDwgc2Nyb2xsaW5nRWRnZVN0YXJ0ICYmIGVsZW1lbnRFZGdlRW5kID4gc2Nyb2xsaW5nRWRnZUVuZCkgfHxcbiAgICAgICAgKGVsZW1lbnRFZGdlU3RhcnQgPiBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPCBzY3JvbGxpbmdFZGdlRW5kKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEEgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQSBhbmQgZWxlbWVudCBoZWlnaHQgaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggaGVpZ2h0XG4gICAgICpcbiAgICAgKiAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgKiAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTICAgICAgICAg4pSP4pSB4pSM4pSB4pSB4pSQ4pSB4pSTXG4gICAgICogICAgICAgICAg4pSU4pSA4pSA4pSYICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogIGZyb20gIOKUgyAgICAgIOKUgyAgICAgdG8gIOKUgyDilJTilIDilIDilJgg4pSDXG4gICAgICpcbiAgICAgKiAgICAgICAg4pSX4pSBIOKUgeKUgSDilIHilJsgICAgICAgICDilJfilIEg4pSB4pSBIOKUgeKUm1xuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEIgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQiBhbmQgZWxlbWVudCBoZWlnaHQgaXMgZ3JlYXRlciB0aGFuIHNjcm9sbGluZyBib3ggaGVpZ2h0XG4gICAgICpcbiAgICAgKiAgICAgICAg4pSP4pSBIOKUgeKUgSDilIHilJMgICAgICAgICDilI/ilIHilIzilIHilIHilJDilIHilJNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogIGZyb20gIOKUgyDilIzilIDilIDilJAg4pSDICAgICB0byAg4pSDIOKUgiAg4pSCIOKUg1xuICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUl+KUgeKUguKUgeKUgeKUguKUgeKUmyAgICAgICAgIOKUl+KUgeKUguKUgeKUgeKUguKUgeKUm1xuICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgICAg4pSU4pSA4pSA4pSYXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQyBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBDIGFuZCBlbGVtZW50IHdpZHRoIGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IHdpZHRoXG4gICAgICpcbiAgICAgKiAgICAgICBmcm9tICAgICAgICAgICAgICAgICB0b1xuICAgICAqICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAg4pSM4pSA4pSA4pSA4pSQICAgICAgICAgICAgICAgICDilIzilIDilIDilIDilJBcbiAgICAgKiAg4pSCIOKUgyDilIIgICAgICAg4pSDICAgICAgICAg4pSDICAg4pSCICAgICDilINcbiAgICAgKiAg4pSU4pSA4pSA4pSA4pSYICAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJhcbiAgICAgKiAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUmyAgICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgRCBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBEIGFuZCBlbGVtZW50IHdpZHRoIGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IHdpZHRoXG4gICAgICpcbiAgICAgKiAgICAgICBmcm9tICAgICAgICAgICAgICAgICB0b1xuICAgICAqICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICogICAg4pSDICAg4pSCICAgICDilIMgICAgIOKUgiAgIOKUgyAgICAgICAgIOKUgyDilIJcbiAgICAgKiAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICogICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqL1xuICAgIGlmICgoZWxlbWVudEVkZ2VTdGFydCA8PSBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudFNpemUgPD0gc2Nyb2xsaW5nU2l6ZSkgfHxcbiAgICAgICAgKGVsZW1lbnRFZGdlRW5kID49IHNjcm9sbGluZ0VkZ2VFbmQgJiYgZWxlbWVudFNpemUgPj0gc2Nyb2xsaW5nU2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVmdE9yVG9wICovO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQiBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBCIGFuZCBlbGVtZW50IGhlaWdodCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgKlxuICAgICAqICAgICAgICDilI/ilIEg4pSB4pSBIOKUgeKUkyAgICAgICAgIOKUj+KUgSDilIHilIEg4pSB4pSTXG4gICAgICpcbiAgICAgKiAgZnJvbSAg4pSDICAgICAg4pSDICAgICB0byAg4pSDIOKUjOKUgOKUgOKUkCDilINcbiAgICAgKiAgICAgICAgICDilIzilIDilIDilJAgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbICAgICAgICAg4pSX4pSB4pSU4pSB4pSB4pSY4pSB4pSbXG4gICAgICogICAgICAgICAg4pSU4pSA4pSA4pSYXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQSBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBBIGFuZCBlbGVtZW50IGhlaWdodCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgKlxuICAgICAqICAgICAgICAgIOKUjOKUgOKUgOKUkFxuICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICogICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUkyAgICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUk1xuICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogIGZyb20gIOKUgyDilJTilIDilIDilJgg4pSDICAgICB0byAg4pSDIOKUgiAg4pSCIOKUg1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAg4pSX4pSBIOKUgeKUgSDilIHilJsgICAgICAgICDilJfilIHilJTilIHilIHilJjilIHilJtcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBDIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEMgYW5kIGVsZW1lbnQgd2lkdGggaXMgZ3JlYXRlciB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgKlxuICAgICAqICAgICAgICAgICBmcm9tICAgICAgICAgICAgICAgICB0b1xuICAgICAqICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICogIOKUgiAgICAg4pSDICAgICDilIIgICDilIMgICAgICAg4pSCIOKUgyAgICAgICAgIOKUg1xuICAgICAqICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgICAqICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUmyAgICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgRCBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBEIGFuZCBlbGVtZW50IHdpZHRoIGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IHdpZHRoXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgKiAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJMgICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkCAgICAgICAgICAgICDilIzilIDilIDilIDilJBcbiAgICAgKiAgICAgICAg4pSDICAgICAgIOKUgiDilIMg4pSCICAgICAgIOKUgyAgICAg4pSCICAg4pSDXG4gICAgICogICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmFxuICAgICAqICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUmyAgICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICpcbiAgICAgKi9cbiAgICBpZiAoKGVsZW1lbnRFZGdlRW5kID4gc2Nyb2xsaW5nRWRnZUVuZCAmJiBlbGVtZW50U2l6ZSA8IHNjcm9sbGluZ1NpemUpIHx8XG4gICAgICAgIChlbGVtZW50RWRnZVN0YXJ0IDwgc2Nyb2xsaW5nRWRnZVN0YXJ0ICYmIGVsZW1lbnRTaXplID4gc2Nyb2xsaW5nU2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIDMgLyogUmlnaHRPckJvdHRvbSAqLztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgY2FuT3ZlcmZsb3cgPSAob3ZlcmZsb3cpID0+IHtcbiAgICByZXR1cm4gb3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiICYmIG92ZXJmbG93ICE9PSBcImNsaXBcIjtcbn07XG5jb25zdCBnZXRGcmFtZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKChfYSA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyYW1lRWxlbWVudCkgfHwgbnVsbDtcbiAgICB9XG4gICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5jb25zdCBpc1Njcm9sbGFibGUgPSAoZWxlbWVudCwgY29tcHV0ZWRTdHlsZSkgPT4ge1xuICAgIGlmIChlbGVtZW50LmNsaWVudEhlaWdodCA8IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50V2lkdGggPCBlbGVtZW50LnNjcm9sbFdpZHRoKSB7XG4gICAgICAgIHJldHVybiAoY2FuT3ZlcmZsb3coY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1kpIHx8XG4gICAgICAgICAgICBjYW5PdmVyZmxvdyhjb21wdXRlZFN0eWxlLm92ZXJmbG93WCkgfHxcbiAgICAgICAgICAgIGVsZW1lbnQgPT09IHNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgcGFyZW50RWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgY29uc3QgcEVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKHBFbGVtZW50ID09PSBudWxsICYmIHBOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwTm9kZS5ub2RlVHlwZSA9PT0gLyoqIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAqLyAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIHBOb2RlLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBOb2RlLm5vZGVUeXBlID09PSAvKiogTm9kZS5ET0NVTUVOVF9OT0RFICovIDkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRGcmFtZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBFbGVtZW50O1xufTtcbmNvbnN0IGNsYW1wID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IGdldFN1cHBvcnRlZFNjcm9sbE1hcmdpblByb3BlcnR5ID0gKG93bmVyRG9jdW1lbnQpID0+IHtcbiAgICAvLyBXZWJraXQgdXNlcyBcInNjcm9sbC1zbmFwLW1hcmdpblwiIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODkyNjUuXG4gICAgcmV0dXJuIFtcInNjcm9sbC1tYXJnaW5cIiwgXCJzY3JvbGwtc25hcC1tYXJnaW5cIl0uZmlsdGVyKChwcm9wZXJ0eSkgPT4gcHJvcGVydHkgaW4gb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpWzBdO1xufTtcbmNvbnN0IGdldEVsZW1lbnRTY3JvbGxTbmFwQXJlYSA9IChlbGVtZW50LCBlbGVtZW50UmVjdCwgY29tcHV0ZWRTdHlsZSkgPT4ge1xuICAgIGNvbnN0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IH0gPSBlbGVtZW50UmVjdDtcbiAgICBjb25zdCBzY3JvbGxQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFNjcm9sbE1hcmdpblByb3BlcnR5KGVsZW1lbnQub3duZXJEb2N1bWVudCk7XG4gICAgaWYgKCFzY3JvbGxQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF07XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbE1hcmdpblZhbHVlID0gKGVkZ2UpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoYCR7c2Nyb2xsUHJvcGVydHl9LSR7ZWRnZX1gKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCkgfHwgMDtcbiAgICB9O1xuICAgIHJldHVybiBbXG4gICAgICAgIHRvcCAtIHNjcm9sbE1hcmdpblZhbHVlKFwidG9wXCIpLFxuICAgICAgICByaWdodCArIHNjcm9sbE1hcmdpblZhbHVlKFwicmlnaHRcIiksXG4gICAgICAgIGJvdHRvbSArIHNjcm9sbE1hcmdpblZhbHVlKFwiYm90dG9tXCIpLFxuICAgICAgICBsZWZ0IC0gc2Nyb2xsTWFyZ2luVmFsdWUoXCJsZWZ0XCIpLFxuICAgIF07XG59O1xuY29uc3QgY2FsY0FsaWduRWRnZSA9IChhbGlnbiwgc3RhcnQsIGVuZCkgPT4ge1xuICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAxIC8qIENlbnRlckFsd2F5cyAqLzpcbiAgICAgICAgICAgIHJldHVybiAoc3RhcnQgKyBlbmQpIC8gMjtcbiAgICAgICAgY2FzZSAzIC8qIFJpZ2h0T3JCb3R0b20gKi86XG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICBjYXNlIDIgLyogTGVmdE9yVG9wICovOlxuICAgICAgICBjYXNlIDAgLyogVG9FZGdlSWZOZWVkZWQgKi86XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfVxufTtcbmNvbnN0IGdldEZyYW1lVmlld3BvcnQgPSAoZnJhbWUsIGZyYW1lUmVjdCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gKF9hID0gZnJhbWUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpc3VhbFZpZXdwb3J0O1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGZyYW1lID09PSBzY3JvbGxpbmdFbGVtZW50KGZyYW1lKVxuICAgICAgICA/IFswLCAwLCAoX2IgPSB2aXN1YWxWaWV3cG9ydCA9PT0gbnVsbCB8fCB2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsVmlld3BvcnQud2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZyYW1lLmNsaWVudFdpZHRoLCAoX2MgPSB2aXN1YWxWaWV3cG9ydCA9PT0gbnVsbCB8fCB2aXN1YWxWaWV3cG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsVmlld3BvcnQuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmcmFtZS5jbGllbnRIZWlnaHRdXG4gICAgICAgIDogW2ZyYW1lUmVjdC5sZWZ0LCBmcmFtZVJlY3QudG9wLCBmcmFtZS5jbGllbnRXaWR0aCwgZnJhbWUuY2xpZW50SGVpZ2h0XTtcbiAgICBjb25zdCBsZWZ0ID0geCArIGZyYW1lLmNsaWVudExlZnQ7XG4gICAgY29uc3QgdG9wID0geSArIGZyYW1lLmNsaWVudFRvcDtcbiAgICBjb25zdCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdO1xufTtcbmNvbnN0IGNvbXB1dGVTY3JvbGxJbnRvVmlldyA9IChlbGVtZW50LCBvcHRpb25zKSA9PiB7XG4gICAgLy8gQ29sbGVjdCBhbGwgdGhlIHNjcm9sbGluZyBib3hlcywgYXMgZGVmaW5lZCBpbiB0aGUgc3BlYzogaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLXZpZXcvI3Njcm9sbGluZy1ib3hcbiAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgbGV0IG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgbGV0IG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBpZiAoIW93bmVyV2luZG93KSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgY29uc3QgaXNMVFIgPSBjb21wdXRlZFN0eWxlLmRpcmVjdGlvbiAhPT0gXCJydGxcIjtcbiAgICBjb25zdCB3cml0aW5nTW9kZSA9IG5vcm1hbGl6ZVdyaXRpbmdNb2RlKGNvbXB1dGVkU3R5bGUud3JpdGluZ01vZGUgfHxcbiAgICAgICAgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLXdlYmtpdC13cml0aW5nLW1vZGVcIikgfHxcbiAgICAgICAgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLW1zLXdyaXRpbmctbW9kZVwiKSk7XG4gICAgY29uc3QgW2FsaWduSCwgYWxpZ25WXSA9IHRvUGh5c2ljYWxBbGlnbm1lbnQob3B0aW9ucywgd3JpdGluZ01vZGUsIGlzTFRSKTtcbiAgICBsZXQgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0gPSBnZXRFbGVtZW50U2Nyb2xsU25hcEFyZWEoZWxlbWVudCwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgY29tcHV0ZWRTdHlsZSk7XG4gICAgZm9yIChsZXQgZnJhbWUgPSBwYXJlbnRFbGVtZW50KGVsZW1lbnQpOyBmcmFtZSAhPT0gbnVsbDsgZnJhbWUgPSBwYXJlbnRFbGVtZW50KGZyYW1lKSkge1xuICAgICAgICBpZiAob3duZXJEb2N1bWVudCAhPT0gZnJhbWUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgb3duZXJEb2N1bWVudCA9IGZyYW1lLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICBpZiAoIW93bmVyV2luZG93KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGxlZnQ6IGRYLCB0b3A6IGRZIH0gPSBmcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRvcCArPSBkWTtcbiAgICAgICAgICAgIHJpZ2h0ICs9IGRYO1xuICAgICAgICAgICAgYm90dG9tICs9IGRZO1xuICAgICAgICAgICAgbGVmdCArPSBkWDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZVN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShmcmFtZSk7XG4gICAgICAgIGlmIChmcmFtZVN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTY3JvbGxhYmxlKGZyYW1lLCBmcmFtZVN0eWxlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWVSZWN0ID0gZnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IFtmcmFtZVRvcCwgZnJhbWVSaWdodCwgZnJhbWVCb3R0b20sIGZyYW1lTGVmdF0gPSBnZXRGcmFtZVZpZXdwb3J0KGZyYW1lLCBmcmFtZVJlY3QpO1xuICAgICAgICBjb25zdCBlQWxpZ25IID0gbWFwTmVhcmVzdChhbGlnbkgsIGZyYW1lTGVmdCwgZnJhbWVSaWdodCwgZnJhbWUuY2xpZW50V2lkdGgsIGxlZnQsIHJpZ2h0LCByaWdodCAtIGxlZnQpO1xuICAgICAgICBjb25zdCBlQWxpZ25WID0gbWFwTmVhcmVzdChhbGlnblYsIGZyYW1lVG9wLCBmcmFtZUJvdHRvbSwgZnJhbWUuY2xpZW50SGVpZ2h0LCB0b3AsIGJvdHRvbSwgYm90dG9tIC0gdG9wKTtcbiAgICAgICAgY29uc3QgZGlmZlggPSBlQWxpZ25IID09PSBudWxsID8gMCA6IGNhbGNBbGlnbkVkZ2UoZUFsaWduSCwgbGVmdCwgcmlnaHQpIC0gY2FsY0FsaWduRWRnZShlQWxpZ25ILCBmcmFtZUxlZnQsIGZyYW1lUmlnaHQpO1xuICAgICAgICBjb25zdCBkaWZmWSA9IGVBbGlnblYgPT09IG51bGwgPyAwIDogY2FsY0FsaWduRWRnZShlQWxpZ25WLCB0b3AsIGJvdHRvbSkgLSBjYWxjQWxpZ25FZGdlKGVBbGlnblYsIGZyYW1lVG9wLCBmcmFtZUJvdHRvbSk7XG4gICAgICAgIGNvbnN0IG1vdmVYID0gaXNYUmV2ZXJzZWQoZnJhbWVTdHlsZSlcbiAgICAgICAgICAgID8gY2xhbXAoZGlmZlgsIC1mcmFtZS5zY3JvbGxXaWR0aCArIGZyYW1lLmNsaWVudFdpZHRoIC0gZnJhbWUuc2Nyb2xsTGVmdCwgLWZyYW1lLnNjcm9sbExlZnQpXG4gICAgICAgICAgICA6IGNsYW1wKGRpZmZYLCAtZnJhbWUuc2Nyb2xsTGVmdCwgZnJhbWUuc2Nyb2xsV2lkdGggLSBmcmFtZS5jbGllbnRXaWR0aCAtIGZyYW1lLnNjcm9sbExlZnQpO1xuICAgICAgICBjb25zdCBtb3ZlWSA9IGNsYW1wKGRpZmZZLCAtZnJhbWUuc2Nyb2xsVG9wLCBmcmFtZS5zY3JvbGxIZWlnaHQgLSBmcmFtZS5jbGllbnRIZWlnaHQgLSBmcmFtZS5zY3JvbGxUb3ApO1xuICAgICAgICBhY3Rpb25zLnB1c2goW1xuICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICB7IGxlZnQ6IGZyYW1lLnNjcm9sbExlZnQgKyBtb3ZlWCwgdG9wOiBmcmFtZS5zY3JvbGxUb3AgKyBtb3ZlWSwgYmVoYXZpb3I6IG9wdGlvbnMuYmVoYXZpb3IgfSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCAtIG1vdmVZLCBmcmFtZVRvcCk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQgLSBtb3ZlWCwgZnJhbWVSaWdodCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSAtIG1vdmVZLCBmcmFtZUJvdHRvbSk7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0IC0gbW92ZVgsIGZyYW1lTGVmdCk7XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb25zO1xufTtcbmV4cG9ydCBjb25zdCBzY3JvbGxJbnRvVmlldyA9IChlbGVtZW50LCBzY3JvbGxJbnRvVmlld09wdGlvbnMsIGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzY3JvbGxJbnRvVmlld09wdGlvbnMgfHwge307XG4gICAgaWYgKCFjaGVja0JlaGF2aW9yKG9wdGlvbnMuYmVoYXZpb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZmFpbGVkRXhlY3V0ZUludmFsaWRFbnVtVmFsdWUoXCJzY3JvbGxJbnRvVmlld1wiLCBcIkVsZW1lbnRcIiwgb3B0aW9ucy5iZWhhdmlvcikpO1xuICAgIH1cbiAgICBjb25zdCBhY3Rpb25zID0gY29tcHV0ZVNjcm9sbEludG9WaWV3KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIGFjdGlvbnMuZm9yRWFjaCgoW2ZyYW1lLCBzY3JvbGxUb09wdGlvbnNdKSA9PiB7XG4gICAgICAgIGVsZW1lbnRTY3JvbGwoZnJhbWUsIHNjcm9sbFRvT3B0aW9ucywgY29uZmlnKTtcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgZWxlbWVudFNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JvbGxJbnRvVmlldy5qcy5tYXAiLCJpbXBvcnQgeyBlbGVtZW50U2Nyb2xsSW50b1ZpZXcgfSBmcm9tICdzZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwnO1xyXG5cclxuY29uc3QgbWVudUJ1dHRvbnMgPSAoKSA9PiB7XHJcblx0Y29uc3QgaGVhZGVyTWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXItbWVudScpO1xyXG5cdGNvbnNvbGUubG9nKCd+IGhlYWRlck1lbnUnLCBoZWFkZXJNZW51KTtcclxuXHJcblx0Y29uc3Qgc2Nyb2xsVXAgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcblx0XHRlbGVtZW50U2Nyb2xsSW50b1ZpZXcob2JqZWN0LCB7IGJlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInLCBpbmxpbmU6ICdjZW50ZXInIH0pO1xyXG5cdH07XHJcblxyXG5cdGhlYWRlck1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG5cdFx0Ly8gY29uc29sZS5sb2coZS50YXJnZXQpO1xyXG5cclxuXHRcdGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2hlYWRlci1tZW51LWl0ZW0nKSkge1xyXG5cdFx0XHRjb25zdCBpdGVtTGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpLnN1YnN0cmluZygxKSk7XHJcblx0XHRcdHNjcm9sbFVwLmJpbmQoaXRlbUxpbmspKGl0ZW1MaW5rKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Y29uc29sZS5sb2coJ3Njcm9sbEludG9WaWV3Jyk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtZW51QnV0dG9ucztcclxuIiwiY29uc3Qgc2tpbGxzQW5pbWF0aW9uID0gKHNraWxsc0FycmF5KSA9PiB7XHJcblxyXG5cclxuXHJcblxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2tpbGxzQW5pbWF0aW9uO1xyXG4iLCJpbXBvcnQgY2hvb3NlQWJvdXQgZnJvbSAnLi9tb2R1bGVzL2Nob29zZUFib3V0JztcclxuaW1wb3J0IG1lbnVCdXR0b25zIGZyb20gJy4vbW9kdWxlcy9tZW51QnV0dG9ucyc7XHJcbmltcG9ydCBza2lsbHNBbmltYXRpb24gZnJvbSAnLi9tb2R1bGVzL3NraWxsc0FuaW1hdGlvbic7XHJcblxyXG5jaG9vc2VBYm91dCgpO1xyXG5tZW51QnV0dG9ucygpO1xyXG5za2lsbHNBbmltYXRpb24oW1xyXG5cdHtcclxuXHRcdHNraWxsOiAnSFRNTCAmIENTUycsXHJcblx0XHR2YWx1ZTogNTAsXHJcblx0fSxcclxuXHR7XHJcblx0XHRza2lsbDogJ0phdmFTcmlwdCcsXHJcblx0XHR2YWx1ZTogODAsXHJcblx0fSxcclxuXHR7XHJcblx0XHRza2lsbDogJ0dJVCcsXHJcblx0XHR2YWx1ZTogNDAsXHJcblx0fSxcclxuXHR7XHJcblx0XHRza2lsbDogJ1dFQlBBQ0snLFxyXG5cdFx0dmFsdWU6IDQwLFxyXG5cdH0sXHJcblx0e1xyXG5cdFx0c2tpbGw6ICdTQ1NTL1NBU1MnLFxyXG5cdFx0dmFsdWU6IDIwLFxyXG5cdH0sXHJcblx0e1xyXG5cdFx0c2tpbGw6ICdCT09UU1RSQVAnLFxyXG5cdFx0dmFsdWU6IDIwLFxyXG5cdH0sXHJcblx0e1xyXG5cdFx0c2tpbGw6ICdHVUxQJyxcclxuXHRcdHZhbHVlOiAxMCxcclxuXHR9LFxyXG5cdHtcclxuXHRcdHNraWxsOiAnUFVHJyxcclxuXHRcdHZhbHVlOiAxMCxcclxuXHR9LFxyXG5cdHtcclxuXHRcdHNraWxsOiAnUEhPVE9TSE9QJyxcclxuXHRcdHZhbHVlOiA4MCxcclxuXHR9LFxyXG5cdHtcclxuXHRcdHNraWxsOiAnRklHTUEnLFxyXG5cdFx0dmFsdWU6IDIwLFxyXG5cdH0sXHJcblx0e1xyXG5cdFx0c2tpbGw6ICdSRUFDVCcsXHJcblx0XHR2YWx1ZTogMTAsXHJcblx0fSxcclxuXSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///482\n')}},__webpack_exports__={};__webpack_modules__[482]()})();