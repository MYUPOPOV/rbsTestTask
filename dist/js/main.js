(()=>{"use strict";var __webpack_modules__={89:()=>{eval("\n;// CONCATENATED MODULE: ./modules/chooseAbout.js\nconst chooseAbout = () => {\r\n\tconst chooseBlock = document.querySelector('.i5-about-choose');\r\n\tconst chooseBlockAll = document.querySelectorAll('.i5-about-choose-block');\r\n\tconst aboutContentAll = document.querySelectorAll('.i5-about-content');\r\n\r\n\tchooseBlock.addEventListener('click', (e) => {\r\n\t\tif (e.target.closest('.i5-about-choose-block')) {\r\n\t\t\tchooseBlockAll.forEach((item, index) => {\r\n\t\t\t\taboutContentAll[index].classList.add('hidden');\r\n\t\t\t\tchooseBlockAll[index].classList.remove('selected');\r\n\t\t\t\tif (item === e.target.closest('.i5-about-choose-block')) {\r\n\t\t\t\t\taboutContentAll[index].classList.toggle('hidden');\r\n\t\t\t\t\tchooseBlockAll[index].classList.toggle('selected');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\r\n\taboutContentAll[0].classList.toggle('hidden');\r\n\tchooseBlockAll[0].classList.toggle('selected');\r\n};\r\n\r\n/* harmony default export */ const modules_chooseAbout = (chooseAbout);\r\n\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/common.js\nconst checkBehavior = (behavior) => {\n    return behavior === undefined || behavior === \"auto\" || behavior === \"instant\" || behavior === \"smooth\";\n};\nfunction elementScrollXY(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\nconst failedExecute = (method, object, reason = \"cannot convert to dictionary.\") => `Failed to execute '${method}' on '${object}': ${reason}`;\nconst failedExecuteInvalidEnumValue = (method, object, value) => failedExecute(method, object, `The provided value '${value}' is not a valid enum value of type ScrollBehavior.`);\n/* eslint-disable */\nconst backupMethod = (proto, method, fallback) => {\n    var _a;\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n    if (!proto[backup] && proto[method] && !((_a = proto[method]) === null || _a === void 0 ? void 0 : _a.__isPolyfill)) {\n        proto[backup] = proto[method];\n    }\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\nconst isObject = (value) => {\n    const type = typeof value;\n    return value !== null && (type === \"object\" || type === \"function\");\n};\nconst isScrollBehaviorSupported = () => \"scrollBehavior\" in window.document.documentElement.style;\nconst markPolyfill = (method) => {\n    Object.defineProperty(method, \"__isPolyfill\", { value: true });\n};\nconst modifyPrototypes = (prop, func) => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nconst scrollingElement = (element) => element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n//# sourceMappingURL=common.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scroll-step.js\nconst ease = (k) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n/* eslint-disable */\nfunction now() {\n    var _a;\n    let fn;\n    if ((_a = window.performance) === null || _a === void 0 ? void 0 : _a.now) {\n        fn = () => window.performance.now();\n    }\n    else {\n        fn = () => window.Date.now();\n    }\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\nconst DURATION = 500;\nconst step = (context) => {\n    const currentTime = now();\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n    context.method(currentX, currentY);\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n//# sourceMappingURL=scroll-step.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scroll.js\n\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value) => {\n    if (!isFinite(value)) {\n        return 0;\n    }\n    return Number(value);\n};\nconst isConnected = (node) => {\n    var _a;\n    return ((_a = node.isConnected) !== null && _a !== void 0 ? _a : (!node.ownerDocument ||\n        // eslint-disable-next-line no-bitwise\n        !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1)));\n};\nconst scrollWithOptions = (element, options, config) => {\n    var _a, _b;\n    if (!isConnected(element)) {\n        return;\n    }\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n    const targetX = nonFinite((_a = options.left) !== null && _a !== void 0 ? _a : startX);\n    const targetY = nonFinite((_b = options.top) !== null && _b !== void 0 ? _b : startY);\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n    const fallback = backupMethod(HTMLElement.prototype, \"scroll\", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element), \"scroll\", fallback).bind(element);\n    if (options.behavior !== \"smooth\") {\n        method(targetX, targetY);\n        return;\n    }\n    const removeEventListener = () => {\n        window.removeEventListener(\"wheel\", cancelScroll);\n        window.removeEventListener(\"touchmove\", cancelScroll);\n    };\n    const context = Object.assign(Object.assign({}, config), { timeStamp: now(), startX,\n        startY,\n        targetX,\n        targetY, rafId: 0, method, callback: removeEventListener });\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n    window.addEventListener(\"wheel\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener(\"touchmove\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    step(context);\n};\nconst isWindow = (obj) => obj.window === obj;\nconst createScroll = (scrollName) => (target, scrollOptions, config) => {\n    const [element, scrollType] = isWindow(target)\n        ? [scrollingElement(target.document.documentElement), \"Window\"]\n        : [target, \"Element\"];\n    const options = scrollOptions !== null && scrollOptions !== void 0 ? scrollOptions : {};\n    if (!isObject(options)) {\n        throw new TypeError(failedExecute(scrollName, scrollType));\n    }\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n    }\n    if (scrollName === \"scrollBy\") {\n        options.left = nonFinite(options.left) + element.scrollLeft;\n        options.top = nonFinite(options.top) + element.scrollTop;\n    }\n    scrollWithOptions(element, options, config);\n};\nconst scroll_scroll = /* #__PURE__ */ createScroll(\"scroll\");\nconst scrollTo = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollTo\")));\nconst scrollBy = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollBy\")));\nconst elementScroll = scroll_scroll;\nconst elementScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst elementScrollBy = (/* unused pure expression or super */ null && (scrollBy));\nconst windowScroll = (/* unused pure expression or super */ null && (scroll_scroll));\nconst windowScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst windowScrollBy = (/* unused pure expression or super */ null && (scrollBy));\n//# sourceMappingURL=scroll.js.map\n;// CONCATENATED MODULE: ../node_modules/seamless-scroll-polyfill/lib/scrollIntoView.js\n/* eslint-disable no-bitwise */\n\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode) => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return 0 /* HorizontalTb */;\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return 1 /* VerticalRl */;\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return 2 /* VerticalLr */;\n        case \"sideways-rl\":\n            return 3 /* SidewaysRl */;\n        case \"sideways-lr\":\n            return 4 /* SidewaysLr */;\n    }\n    return 0 /* HorizontalTb */;\n};\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= 2 /* ReverseVertical */;\n    }\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case 0 /* HorizontalTb */:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case 1 /* VerticalRl */:\n        case 3 /* SidewaysRl */:\n            //  reverse horizontal\n            layout ^= 1 /* ReverseHorizontal */;\n            break;\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case 4 /* SidewaysLr */:\n            // reverse vertical\n            layout ^= 2 /* ReverseVertical */;\n            break;\n    }\n    return [layout, hPos, vPos];\n};\nconst isXReversed = (computedStyle) => {\n    const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n    return (layout & 1) === 1;\n};\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return 1 /* CenterAlways */;\n            case \"nearest\":\n                return 0 /* ToEdgeIfNeeded */;\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? 2 /* LeftOrTop */ : 3 /* RightOrBottom */;\n            }\n        }\n    });\n};\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n    if (align !== 0 /* ToEdgeIfNeeded */) {\n        return align;\n    }\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n        return null;\n    }\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n        return 2 /* LeftOrTop */;\n    }\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n        return 3 /* RightOrBottom */;\n    }\n    return null;\n};\nconst canOverflow = (overflow) => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\nconst getFrameElement = (element) => {\n    var _a;\n    try {\n        return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n    }\n    catch (_b) {\n        return null;\n    }\n};\nconst isScrollable = (element, computedStyle) => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element));\n    }\n    return false;\n};\nconst parentElement = (element) => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return pNode.host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n    return pElement;\n};\nconst clamp = (value, min, max) => {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n};\nconst getSupportedScrollMarginProperty = (ownerDocument) => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return [\"scroll-margin\", \"scroll-snap-margin\"].filter((property) => property in ownerDocument.documentElement.style)[0];\n};\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n    const scrollMarginValue = (edge) => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\nconst calcAlignEdge = (align, start, end) => {\n    switch (align) {\n        case 1 /* CenterAlways */:\n            return (start + end) / 2;\n        case 3 /* RightOrBottom */:\n            return end;\n        case 2 /* LeftOrTop */:\n        case 0 /* ToEdgeIfNeeded */:\n            return start;\n    }\n};\nconst getFrameViewport = (frame, frameRect) => {\n    var _a, _b, _c;\n    const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n    const [x, y, width, height] = frame === scrollingElement(frame)\n        ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight]\n        : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n    return [top, right, bottom, left];\n};\nconst computeScrollIntoView = (element, options) => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions = [];\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n    if (!ownerWindow) {\n        return actions;\n    }\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n    const writingMode = normalizeWritingMode(computedStyle.writingMode ||\n        computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n        computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n        const frameRect = frame.getBoundingClientRect();\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n        const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n    return actions;\n};\nconst scrollIntoView = (element, scrollIntoViewOptions, config) => {\n    const options = scrollIntoViewOptions || {};\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n    const actions = computeScrollIntoView(element, options);\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\nconst elementScrollIntoView = scrollIntoView;\n//# sourceMappingURL=scrollIntoView.js.map\n;// CONCATENATED MODULE: ./modules/scrollIntoView.js\n\r\n\r\nconst scrollIntoView_scrollIntoView = () => {\r\n\tconst headerMenu = document.querySelector('.header-menu');\r\n\r\n\tconst scrollUp = function (object) {\r\n\t\telementScrollIntoView(object, { behavior: 'smooth', block: 'center', inline: 'center' });\r\n\t};\r\n\r\n\theaderMenu.addEventListener('click', (e) => {\r\n\t\tif (e.target.classList.contains('header-menu-item')) {\r\n\t\t\tconst itemLink = document.getElementById(e.target.getAttribute('href').substring(1));\r\n\t\t\tscrollUp.bind(itemLink)(itemLink);\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/* harmony default export */ const modules_scrollIntoView = (scrollIntoView_scrollIntoView);\r\n\n;// CONCATENATED MODULE: ./modules/changeTheme.js\nconst changeTheme = () => {\r\n\tconst button = document.getElementById('change-theme-button');\r\n\r\n\tconst body = document.querySelector('body');\r\n\tconst header = document.querySelector('.header');\r\n\tconst headerMenuThemeButton = document.querySelector('.header-menu-theme-button');\r\n\tconst i2SkillsItemBox = document.querySelector('.i2-skills-item-box');\r\n\tconst footer = document.querySelector('.footer');\r\n\tconst item1 = document.querySelector('.i1');\r\n\tconst item2 = document.querySelector('.i2');\r\n\tconst item3 = document.querySelector('.i3');\r\n\tconst item4 = document.querySelector('.i4');\r\n\tconst item5 = document.querySelector('.i5');\r\n\tconst item6 = document.querySelector('.i6');\r\n\tconst array = [body, header, headerMenuThemeButton, i2SkillsItemBox, footer, item1, item2, item3, item4, item5, item6];\r\n\r\n\tconst toggleTheme = () => {\r\n\t\tarray.forEach((item) => {\r\n\t\t\titem.classList.toggle('dark-mode');\r\n\t\t});\r\n\t};\r\n\r\n\tbutton.addEventListener('click', () => {\r\n\t\ttoggleTheme();\r\n\t\tif (body.classList.contains('dark-mode')) {\r\n\t\t\tlocalStorage.setItem('isDarkMode', true);\r\n\t\t\tbutton.textContent = 'Светлый режим';\r\n\t\t} else {\r\n\t\t\tbutton.textContent = 'Тёмный режим';\r\n\t\t\tlocalStorage.setItem('isDarkMode', false);\r\n\t\t}\r\n\t\tisDarkMode = localStorage.getItem('isDarkMode');\r\n\t\tconsole.log('~ isDarkMode', isDarkMode);\r\n\t});\r\n\r\n\tlet isDarkMode = localStorage.getItem('isDarkMode');\r\n\tconsole.log('~ isDarkMode', isDarkMode);\r\n\r\n\tif (isDarkMode === 'true') {\r\n\t\ttoggleTheme();\r\n\t\tbutton.textContent = 'Светлый режим';\r\n\t}\r\n};\r\n\r\n/* harmony default export */ const modules_changeTheme = (changeTheme);\r\n\n;// CONCATENATED MODULE: ./modules/helpers.js\nconst animate = function ({ timing, draw, duration }) {\r\n\tlet start = performance.now();\r\n\r\n\trequestAnimationFrame(function animate(time) {\r\n\t\t// timeFraction изменяется от 0 до 1\r\n\t\tlet timeFraction = (time - start) / duration;\r\n\t\tif (timeFraction > 1) timeFraction = 1;\r\n\r\n\t\t// вычисление текущего состояния анимации\r\n\t\tlet progress = timing(timeFraction);\r\n\r\n\t\tdraw(progress); // отрисовать её\r\n\r\n\t\tif (timeFraction < 1) {\r\n\t\t\trequestAnimationFrame(animate);\r\n\t\t}\r\n\t});\r\n};\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./modules/stickMenu.js\n\r\n\r\nconst stickMenu = () => {\r\n\tconst header = document.querySelector('.header');\r\n\tlet lastScrollTop = window.pageYOffset;\r\n\r\n\tconst menuAnimate = (time) => {\r\n\t\tanimate({\r\n\t\t\tduration: time,\r\n\t\t\ttiming(timeFraction) {\r\n\t\t\t\treturn timeFraction;\r\n\t\t\t},\r\n\t\t\tdraw(progress) {\r\n\t\t\t\theader.style.top = `${-60 + progress * 60}px`;\r\n\t\t\t},\r\n\t\t});\r\n\t};\r\n\r\n\twindow.addEventListener('scroll', () => {\r\n\t\tif (window.pageYOffset < lastScrollTop) {\r\n\t\t\tif (header.style.top != '0px' && header.style.top.substr(0, 1) !== '-') {\r\n\t\t\t\tmenuAnimate(1000);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\theader.style.top = '';\r\n\t\t}\r\n\t\tlastScrollTop = window.pageYOffset;\r\n\t});\r\n};\r\n\r\n/* harmony default export */ const modules_stickMenu = (stickMenu);\r\n\n;// CONCATENATED MODULE: ./modules/skillsAnimation.js\n\r\n\r\nconst skillsAnimation = (skillsArray, time) => {\r\n\tconst skillItems = document.querySelectorAll('.i2-skills-item');\r\n\tconst skillsBlock = document.getElementById('skills');\r\n\tlet index = 0;\r\n\tlet isSkillsAnimationShown = false;\r\n\r\n\tconst getItemText = (index) => {\r\n\t\tskillItems[index].querySelector('.skill-value').textContent = skillsArray[index].value + '%';\r\n\t\tskillItems[index].querySelector('.skill-name').textContent = skillsArray[index].skill;\r\n\t\tindex++;\r\n\t\tif (index < skillItems.length) {\r\n\t\t\tanimateItem(index, time);\r\n\t\t}\r\n\t};\r\n\tconst animateItem = (index, time) => {\r\n\t\tskillItems[index].style.opacity = '1';\r\n\t\tanimate({\r\n\t\t\tduration: (time * skillsArray[index].value) / 30,\r\n\t\t\ttiming(timeFraction) {\r\n\t\t\t\treturn timeFraction;\r\n\t\t\t},\r\n\t\t\tdraw(progress) {\r\n\t\t\t\tskillItems[index].querySelector('.skill-name').style.width = `${progress * skillsArray[index].value}%`;\r\n\t\t\t\tif (progress >= 1) {\r\n\t\t\t\t\tgetItemText(index);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t});\r\n\t};\r\n\r\n\twindow.addEventListener('scroll', () => {\r\n\t\tconst blockY = skillsBlock.getBoundingClientRect().bottom;\r\n\t\tconst pageY = window.pageYOffset + skillsBlock.getBoundingClientRect().height;\r\n\r\n\t\tif (blockY < pageY && !isSkillsAnimationShown) {\r\n\t\t\tisSkillsAnimationShown = true;\r\n\t\t\tanimateItem(index, time);\r\n\t\t}\r\n\t});\r\n};\r\n/* harmony default export */ const modules_skillsAnimation = (skillsAnimation);\r\n\n;// CONCATENATED MODULE: ./index.js\n\r\n\r\n\r\n\r\n\r\n\r\nmodules_chooseAbout();\r\nmodules_scrollIntoView();\r\nmodules_changeTheme();\r\nmodules_stickMenu();\r\nmodules_skillsAnimation(\r\n\t[\r\n\t\t{\r\n\t\t\tskill: 'HTML & CSS',\r\n\t\t\tvalue: 50,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'JAVASCRIPT',\r\n\t\t\tvalue: 80,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'GIT',\r\n\t\t\tvalue: 40,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'WEBPACK',\r\n\t\t\tvalue: 40,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'SCSS/SASS',\r\n\t\t\tvalue: 30,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'BOOTSTRAP',\r\n\t\t\tvalue: 20,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'GULP',\r\n\t\t\tvalue: 30,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'PUG',\r\n\t\t\tvalue: 10,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'PHOTOSHOP',\r\n\t\t\tvalue: 80,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'FIGMA',\r\n\t\t\tvalue: 20,\r\n\t\t},\r\n\t\t{\r\n\t\t\tskill: 'REACT',\r\n\t\t\tvalue: 10,\r\n\t\t},\r\n\t],\r\n\t150\r\n);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLFlBQVk7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdC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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsOERBQWUsZUFBZSxFQUFDOzs7QUMxQ2lCO0FBQ007QUFDTjtBQUNKO0FBQ1k7QUFDeEQ7QUFDQSxtQkFBVztBQUNYLHNCQUFjO0FBQ2QsbUJBQVc7QUFDWCxpQkFBUztBQUNULHVCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL21vZHVsZXMvY2hvb3NlQWJvdXQuanM/ODc4ZSIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbC9saWIvY29tbW9uLmpzPzg1YzYiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL3Njcm9sbC1zdGVwLmpzPzc0YjAiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL3Njcm9sbC5qcz83ZDYzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc2VhbWxlc3Mtc2Nyb2xsLXBvbHlmaWxsL2xpYi9zY3JvbGxJbnRvVmlldy5qcz9jNDRhIiwid2VicGFjazovLy8uL21vZHVsZXMvc2Nyb2xsSW50b1ZpZXcuanM/NGE5YiIsIndlYnBhY2s6Ly8vLi9tb2R1bGVzL2NoYW5nZVRoZW1lLmpzP2U3ZDYiLCJ3ZWJwYWNrOi8vLy4vbW9kdWxlcy9oZWxwZXJzLmpzPzRjNDAiLCJ3ZWJwYWNrOi8vLy4vbW9kdWxlcy9zdGlja01lbnUuanM/YmU5YyIsIndlYnBhY2s6Ly8vLi9tb2R1bGVzL3NraWxsc0FuaW1hdGlvbi5qcz8yYzZmIiwid2VicGFjazovLy8uL2luZGV4LmpzPzQxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY2hvb3NlQWJvdXQgPSAoKSA9PiB7XHJcblx0Y29uc3QgY2hvb3NlQmxvY2sgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaTUtYWJvdXQtY2hvb3NlJyk7XHJcblx0Y29uc3QgY2hvb3NlQmxvY2tBbGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuaTUtYWJvdXQtY2hvb3NlLWJsb2NrJyk7XHJcblx0Y29uc3QgYWJvdXRDb250ZW50QWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmk1LWFib3V0LWNvbnRlbnQnKTtcclxuXHJcblx0Y2hvb3NlQmxvY2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG5cdFx0aWYgKGUudGFyZ2V0LmNsb3Nlc3QoJy5pNS1hYm91dC1jaG9vc2UtYmxvY2snKSkge1xyXG5cdFx0XHRjaG9vc2VCbG9ja0FsbC5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdGFib3V0Q29udGVudEFsbFtpbmRleF0uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcblx0XHRcdFx0Y2hvb3NlQmxvY2tBbGxbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XHJcblx0XHRcdFx0aWYgKGl0ZW0gPT09IGUudGFyZ2V0LmNsb3Nlc3QoJy5pNS1hYm91dC1jaG9vc2UtYmxvY2snKSkge1xyXG5cdFx0XHRcdFx0YWJvdXRDb250ZW50QWxsW2luZGV4XS5jbGFzc0xpc3QudG9nZ2xlKCdoaWRkZW4nKTtcclxuXHRcdFx0XHRcdGNob29zZUJsb2NrQWxsW2luZGV4XS5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGFib3V0Q29udGVudEFsbFswXS5jbGFzc0xpc3QudG9nZ2xlKCdoaWRkZW4nKTtcclxuXHRjaG9vc2VCbG9ja0FsbFswXS5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2hvb3NlQWJvdXQ7XHJcbiIsImV4cG9ydCBjb25zdCBjaGVja0JlaGF2aW9yID0gKGJlaGF2aW9yKSA9PiB7XG4gICAgcmV0dXJuIGJlaGF2aW9yID09PSB1bmRlZmluZWQgfHwgYmVoYXZpb3IgPT09IFwiYXV0b1wiIHx8IGJlaGF2aW9yID09PSBcImluc3RhbnRcIiB8fCBiZWhhdmlvciA9PT0gXCJzbW9vdGhcIjtcbn07XG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudFNjcm9sbFhZKHgsIHkpIHtcbiAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgIHRoaXMuc2Nyb2xsVG9wID0geTtcbn1cbmV4cG9ydCBjb25zdCBmYWlsZWRFeGVjdXRlID0gKG1ldGhvZCwgb2JqZWN0LCByZWFzb24gPSBcImNhbm5vdCBjb252ZXJ0IHRvIGRpY3Rpb25hcnkuXCIpID0+IGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHttZXRob2R9JyBvbiAnJHtvYmplY3R9JzogJHtyZWFzb259YDtcbmV4cG9ydCBjb25zdCBmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZSA9IChtZXRob2QsIG9iamVjdCwgdmFsdWUpID0+IGZhaWxlZEV4ZWN1dGUobWV0aG9kLCBvYmplY3QsIGBUaGUgcHJvdmlkZWQgdmFsdWUgJyR7dmFsdWV9JyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgU2Nyb2xsQmVoYXZpb3IuYCk7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGNvbnN0IGJhY2t1cE1ldGhvZCA9IChwcm90bywgbWV0aG9kLCBmYWxsYmFjaykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBiYWNrdXAgPSBgX19TRUFNTEVTUy5CQUNLVVAkJHttZXRob2R9YDtcbiAgICBpZiAoIXByb3RvW2JhY2t1cF0gJiYgcHJvdG9bbWV0aG9kXSAmJiAhKChfYSA9IHByb3RvW21ldGhvZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fX2lzUG9seWZpbGwpKSB7XG4gICAgICAgIHByb3RvW2JhY2t1cF0gPSBwcm90b1ttZXRob2RdO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdG9bYmFja3VwXSB8fCBmYWxsYmFjaztcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlID09PSBcImZ1bmN0aW9uXCIpO1xufTtcbmV4cG9ydCBjb25zdCBpc1Njcm9sbEJlaGF2aW9yU3VwcG9ydGVkID0gKCkgPT4gXCJzY3JvbGxCZWhhdmlvclwiIGluIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5leHBvcnQgY29uc3QgbWFya1BvbHlmaWxsID0gKG1ldGhvZCkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiX19pc1BvbHlmaWxsXCIsIHsgdmFsdWU6IHRydWUgfSk7XG59O1xuZXhwb3J0IGNvbnN0IG1vZGlmeVByb3RvdHlwZXMgPSAocHJvcCwgZnVuYykgPT4ge1xuICAgIG1hcmtQb2x5ZmlsbChmdW5jKTtcbiAgICBbSFRNTEVsZW1lbnQucHJvdG90eXBlLCBTVkdFbGVtZW50LnByb3RvdHlwZSwgRWxlbWVudC5wcm90b3R5cGVdLmZvckVhY2goKHByb3RvdHlwZSkgPT4ge1xuICAgICAgICBiYWNrdXBNZXRob2QocHJvdG90eXBlLCBwcm9wKTtcbiAgICAgICAgcHJvdG90eXBlW3Byb3BdID0gZnVuYztcbiAgICB9KTtcbn07XG4vKipcbiAqIC0gT24gQ2hyb21lIGFuZCBGaXJlZm94LCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHdpbGwgcmV0dXJuIHRoZSA8aHRtbD4gZWxlbWVudC5cbiAqIC0gU2FmYXJpLCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHdpbGwgcmV0dXJuIHRoZSA8Ym9keT4gZWxlbWVudC5cbiAqIC0gT24gRWRnZSwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB3aWxsIHJldHVybiB0aGUgPGJvZHk+IGVsZW1lbnQuXG4gKiAtIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LCBidXQgeW91IGNhbiBhc3N1bWUgaXRzIDxodG1sPi5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJjb25zdCBlYXNlID0gKGspID0+IHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xufTtcbi8qIGVzbGludC1kaXNhYmxlICovXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm47XG4gICAgaWYgKChfYSA9IHdpbmRvdy5wZXJmb3JtYW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vdykge1xuICAgICAgICBmbiA9ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZuID0gKCkgPT4gd2luZG93LkRhdGUubm93KCk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBub3cgPSBmbjtcbiAgICByZXR1cm4gZm4oKTtcbn1cbi8qIGVzbGludC1lbmFibGUgKi9cbmNvbnN0IERVUkFUSU9OID0gNTAwO1xuZXhwb3J0IGNvbnN0IHN0ZXAgPSAoY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IChjdXJyZW50VGltZSAtIGNvbnRleHQudGltZVN0YW1wKSAvIChjb250ZXh0LmR1cmF0aW9uIHx8IERVUkFUSU9OKTtcbiAgICBpZiAoZWxhcHNlZCA+IDEpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QoY29udGV4dC50YXJnZXRYLCBjb250ZXh0LnRhcmdldFkpO1xuICAgICAgICBjb250ZXh0LmNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSAoY29udGV4dC50aW1pbmdGdW5jIHx8IGVhc2UpKGVsYXBzZWQpO1xuICAgIGNvbnN0IGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC50YXJnZXRYIC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XG4gICAgY29uc3QgY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnRhcmdldFkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcbiAgICBjb250ZXh0Lm1ldGhvZChjdXJyZW50WCwgY3VycmVudFkpO1xuICAgIGNvbnRleHQucmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc3RlcChjb250ZXh0KTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JvbGwtc3RlcC5qcy5tYXAiLCJpbXBvcnQgeyBiYWNrdXBNZXRob2QsIGNoZWNrQmVoYXZpb3IsIGVsZW1lbnRTY3JvbGxYWSwgZmFpbGVkRXhlY3V0ZSwgZmFpbGVkRXhlY3V0ZUludmFsaWRFbnVtVmFsdWUsIGlzT2JqZWN0LCBzY3JvbGxpbmdFbGVtZW50LCB9IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgbm93LCBzdGVwIH0gZnJvbSBcIi4vc2Nyb2xsLXN0ZXAuanNcIjtcbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS12aWV3LyNub3JtYWxpemUtbm9uLWZpbml0ZS12YWx1ZXNcbmNvbnN0IG5vbkZpbml0ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbn07XG5jb25zdCBpc0Nvbm5lY3RlZCA9IChub2RlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gbm9kZS5pc0Nvbm5lY3RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCFub2RlLm93bmVyRG9jdW1lbnQgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgIShub2RlLm93bmVyRG9jdW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiAvKiogRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEICovIDEpKSk7XG59O1xuY29uc3Qgc2Nyb2xsV2l0aE9wdGlvbnMgPSAoZWxlbWVudCwgb3B0aW9ucywgY29uZmlnKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIWlzQ29ubmVjdGVkKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRYID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGNvbnN0IHN0YXJ0WSA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IHRhcmdldFggPSBub25GaW5pdGUoKF9hID0gb3B0aW9ucy5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGFydFgpO1xuICAgIGNvbnN0IHRhcmdldFkgPSBub25GaW5pdGUoKF9iID0gb3B0aW9ucy50b3ApICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHN0YXJ0WSk7XG4gICAgaWYgKHRhcmdldFggPT09IHN0YXJ0WCAmJiB0YXJnZXRZID09PSBzdGFydFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmYWxsYmFjayA9IGJhY2t1cE1ldGhvZChIVE1MRWxlbWVudC5wcm90b3R5cGUsIFwic2Nyb2xsXCIsIGVsZW1lbnRTY3JvbGxYWSk7XG4gICAgY29uc3QgbWV0aG9kID0gYmFja3VwTWV0aG9kKE9iamVjdC5nZXRQcm90b3R5cGVPZihlbGVtZW50KSwgXCJzY3JvbGxcIiwgZmFsbGJhY2spLmJpbmQoZWxlbWVudCk7XG4gICAgaWYgKG9wdGlvbnMuYmVoYXZpb3IgIT09IFwic21vb3RoXCIpIHtcbiAgICAgICAgbWV0aG9kKHRhcmdldFgsIHRhcmdldFkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgY2FuY2VsU2Nyb2xsKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgY2FuY2VsU2Nyb2xsKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgdGltZVN0YW1wOiBub3coKSwgc3RhcnRYLFxuICAgICAgICBzdGFydFksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksIHJhZklkOiAwLCBtZXRob2QsIGNhbGxiYWNrOiByZW1vdmVFdmVudExpc3RlbmVyIH0pO1xuICAgIGNvbnN0IGNhbmNlbFNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGNvbnRleHQucmFmSWQpO1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGNhbmNlbFNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICBvbmNlOiB0cnVlLFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGNhbmNlbFNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICBvbmNlOiB0cnVlLFxuICAgIH0pO1xuICAgIHN0ZXAoY29udGV4dCk7XG59O1xuY29uc3QgaXNXaW5kb3cgPSAob2JqKSA9PiBvYmoud2luZG93ID09PSBvYmo7XG5jb25zdCBjcmVhdGVTY3JvbGwgPSAoc2Nyb2xsTmFtZSkgPT4gKHRhcmdldCwgc2Nyb2xsT3B0aW9ucywgY29uZmlnKSA9PiB7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNjcm9sbFR5cGVdID0gaXNXaW5kb3codGFyZ2V0KVxuICAgICAgICA/IFtzY3JvbGxpbmdFbGVtZW50KHRhcmdldC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLCBcIldpbmRvd1wiXVxuICAgICAgICA6IFt0YXJnZXQsIFwiRWxlbWVudFwiXTtcbiAgICBjb25zdCBvcHRpb25zID0gc2Nyb2xsT3B0aW9ucyAhPT0gbnVsbCAmJiBzY3JvbGxPcHRpb25zICE9PSB2b2lkIDAgPyBzY3JvbGxPcHRpb25zIDoge307XG4gICAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZhaWxlZEV4ZWN1dGUoc2Nyb2xsTmFtZSwgc2Nyb2xsVHlwZSkpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrQmVoYXZpb3Iob3B0aW9ucy5iZWhhdmlvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZShzY3JvbGxOYW1lLCBzY3JvbGxUeXBlLCBvcHRpb25zLmJlaGF2aW9yKSk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxOYW1lID09PSBcInNjcm9sbEJ5XCIpIHtcbiAgICAgICAgb3B0aW9ucy5sZWZ0ID0gbm9uRmluaXRlKG9wdGlvbnMubGVmdCkgKyBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIG9wdGlvbnMudG9wID0gbm9uRmluaXRlKG9wdGlvbnMudG9wKSArIGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBzY3JvbGxXaXRoT3B0aW9ucyhlbGVtZW50LCBvcHRpb25zLCBjb25maWcpO1xufTtcbmV4cG9ydCBjb25zdCBzY3JvbGwgPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlU2Nyb2xsKFwic2Nyb2xsXCIpO1xuZXhwb3J0IGNvbnN0IHNjcm9sbFRvID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVNjcm9sbChcInNjcm9sbFRvXCIpO1xuZXhwb3J0IGNvbnN0IHNjcm9sbEJ5ID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVNjcm9sbChcInNjcm9sbEJ5XCIpO1xuZXhwb3J0IGNvbnN0IGVsZW1lbnRTY3JvbGwgPSBzY3JvbGw7XG5leHBvcnQgY29uc3QgZWxlbWVudFNjcm9sbFRvID0gc2Nyb2xsVG87XG5leHBvcnQgY29uc3QgZWxlbWVudFNjcm9sbEJ5ID0gc2Nyb2xsQnk7XG5leHBvcnQgY29uc3Qgd2luZG93U2Nyb2xsID0gc2Nyb2xsO1xuZXhwb3J0IGNvbnN0IHdpbmRvd1Njcm9sbFRvID0gc2Nyb2xsVG87XG5leHBvcnQgY29uc3Qgd2luZG93U2Nyb2xsQnkgPSBzY3JvbGxCeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5pbXBvcnQgeyBjaGVja0JlaGF2aW9yLCBmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZSwgc2Nyb2xsaW5nRWxlbWVudCB9IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgZWxlbWVudFNjcm9sbCB9IGZyb20gXCIuL3Njcm9sbC5qc1wiO1xuLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy13cml0aW5nLW1vZGVzLTQvI2Jsb2NrLWZsb3dcbmNvbnN0IG5vcm1hbGl6ZVdyaXRpbmdNb2RlID0gKHdyaXRpbmdNb2RlKSA9PiB7XG4gICAgc3dpdGNoICh3cml0aW5nTW9kZSkge1xuICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbC10YlwiOlxuICAgICAgICBjYXNlIFwibHJcIjpcbiAgICAgICAgY2FzZSBcImxyLXRiXCI6XG4gICAgICAgIGNhc2UgXCJybFwiOlxuICAgICAgICBjYXNlIFwicmwtdGJcIjpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIEhvcml6b250YWxUYiAqLztcbiAgICAgICAgY2FzZSBcInZlcnRpY2FsLXJsXCI6XG4gICAgICAgIGNhc2UgXCJ0YlwiOlxuICAgICAgICBjYXNlIFwidGItcmxcIjpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFZlcnRpY2FsUmwgKi87XG4gICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbC1sclwiOlxuICAgICAgICBjYXNlIFwidGItbHJcIjpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIFZlcnRpY2FsTHIgKi87XG4gICAgICAgIGNhc2UgXCJzaWRld2F5cy1ybFwiOlxuICAgICAgICAgICAgcmV0dXJuIDMgLyogU2lkZXdheXNSbCAqLztcbiAgICAgICAgY2FzZSBcInNpZGV3YXlzLWxyXCI6XG4gICAgICAgICAgICByZXR1cm4gNCAvKiBTaWRld2F5c0xyICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBIb3Jpem9udGFsVGIgKi87XG59O1xuY29uc3QgY2FsY1BoeXNpY2FsQXhpcyA9ICh3cml0aW5nTW9kZSwgaXNMVFIsIGhQb3MsIHZQb3MpID0+IHtcbiAgICAvKiogIDBie3ZlcnRpY2FsfXtob3Jpem9udGFsfSAgMDogbm9ybWFsLCAxOiByZXZlcnNlICovXG4gICAgbGV0IGxheW91dCA9IDBiMDA7XG4gICAgLyoqXG4gICAgICogV3JpdGluZ01vZGUuVmVydGljYWxMcjog4oaT4oaSXG4gICAgICogfCAxIHwgNCB8ICAgfFxuICAgICAqIHwgMiB8IDUgfCAgIHxcbiAgICAgKiB8IDMgfCAgIHwgICB8XG4gICAgICpcbiAgICAgKiBSVEw6IOKGkeKGklxuICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgKiB8IDIgfCA1IHwgICB8XG4gICAgICogfCAxIHwgNCB8ICAgfFxuICAgICAqL1xuICAgIGlmICghaXNMVFIpIHtcbiAgICAgICAgbGF5b3V0IF49IDIgLyogUmV2ZXJzZVZlcnRpY2FsICovO1xuICAgIH1cbiAgICBzd2l0Y2ggKHdyaXRpbmdNb2RlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDihpPihpJcbiAgICAgICAgICogfCAxIHwgMiB8IDMgfFxuICAgICAgICAgKiB8IDQgfCA1IHwgICB8XG4gICAgICAgICAqIHwgICB8ICAgfCAgIHxcbiAgICAgICAgICpcbiAgICAgICAgICogUlRMOiDihpPihpBcbiAgICAgICAgICogfCAzIHwgMiB8IDEgfFxuICAgICAgICAgKiB8ICAgfCA1IHwgNCB8XG4gICAgICAgICAqIHwgICB8ICAgfCAgIHxcbiAgICAgICAgICovXG4gICAgICAgIGNhc2UgMCAvKiBIb3Jpem9udGFsVGIgKi86XG4gICAgICAgICAgICAvLyBzd2FwIGhvcml6b250YWwgYW5kIHZlcnRpY2FsXG4gICAgICAgICAgICBsYXlvdXQgPSAobGF5b3V0ID4+IDEpIHwgKChsYXlvdXQgJiAxKSA8PCAxKTtcbiAgICAgICAgICAgIFtoUG9zLCB2UG9zXSA9IFt2UG9zLCBoUG9zXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKipcbiAgICAgICAgICog4oaT4oaQXG4gICAgICAgICAqIHwgICB8IDQgfCAxIHxcbiAgICAgICAgICogfCAgIHwgNSB8IDIgfFxuICAgICAgICAgKiB8ICAgfCAgIHwgMyB8XG4gICAgICAgICAqXG4gICAgICAgICAqIFJUTDog4oaR4oaQXG4gICAgICAgICAqIHwgICB8ICAgfCAzIHxcbiAgICAgICAgICogfCAgIHwgNSB8IDIgfFxuICAgICAgICAgKiB8ICAgfCA0IHwgMSB8XG4gICAgICAgICAqL1xuICAgICAgICBjYXNlIDEgLyogVmVydGljYWxSbCAqLzpcbiAgICAgICAgY2FzZSAzIC8qIFNpZGV3YXlzUmwgKi86XG4gICAgICAgICAgICAvLyAgcmV2ZXJzZSBob3Jpem9udGFsXG4gICAgICAgICAgICBsYXlvdXQgXj0gMSAvKiBSZXZlcnNlSG9yaXpvbnRhbCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKipcbiAgICAgICAgICog4oaR4oaSXG4gICAgICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgICAgICogfCAyIHwgNSB8ICAgfFxuICAgICAgICAgKiB8IDEgfCA0IHwgICB8XG4gICAgICAgICAqXG4gICAgICAgICAqIFJUTDog4oaT4oaSXG4gICAgICAgICAqIHwgMSB8IDQgfCAgIHxcbiAgICAgICAgICogfCAyIHwgNSB8ICAgfFxuICAgICAgICAgKiB8IDMgfCAgIHwgICB8XG4gICAgICAgICAqL1xuICAgICAgICBjYXNlIDQgLyogU2lkZXdheXNMciAqLzpcbiAgICAgICAgICAgIC8vIHJldmVyc2UgdmVydGljYWxcbiAgICAgICAgICAgIGxheW91dCBePSAyIC8qIFJldmVyc2VWZXJ0aWNhbCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gW2xheW91dCwgaFBvcywgdlBvc107XG59O1xuY29uc3QgaXNYUmV2ZXJzZWQgPSAoY29tcHV0ZWRTdHlsZSkgPT4ge1xuICAgIGNvbnN0IGxheW91dCA9IGNhbGNQaHlzaWNhbEF4aXMobm9ybWFsaXplV3JpdGluZ01vZGUoY29tcHV0ZWRTdHlsZS53cml0aW5nTW9kZSksIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uICE9PSBcInJ0bFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZClbMF07XG4gICAgcmV0dXJuIChsYXlvdXQgJiAxKSA9PT0gMTtcbn07XG4vLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp0aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2RvbS9lbGVtZW50LmNjO2w9MTA5Ny0xMTg5O2RyYz02YTc1MzNkNGExZTlmMjM3MjIyM2E5ZDkxMmE5ZTUzYTZmYTM1YWUwXG5jb25zdCB0b1BoeXNpY2FsQWxpZ25tZW50ID0gKG9wdGlvbnMsIHdyaXRpbmdNb2RlLCBpc0xUUikgPT4ge1xuICAgIGNvbnN0IFtsYXlvdXQsIGhQb3MsIHZQb3NdID0gY2FsY1BoeXNpY2FsQXhpcyh3cml0aW5nTW9kZSwgaXNMVFIsIG9wdGlvbnMuYmxvY2sgfHwgXCJzdGFydFwiLCBvcHRpb25zLmlubGluZSB8fCBcIm5lYXJlc3RcIik7XG4gICAgcmV0dXJuIFtoUG9zLCB2UG9zXS5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ2VudGVyQWx3YXlzICovO1xuICAgICAgICAgICAgY2FzZSBcIm5lYXJlc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBUb0VkZ2VJZk5lZWRlZCAqLztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXZlcnNlID0gKGxheW91dCA+PiBpbmRleCkgJiAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IFwic3RhcnRcIikgPT09ICFyZXZlcnNlID8gMiAvKiBMZWZ0T3JUb3AgKi8gOiAzIC8qIFJpZ2h0T3JCb3R0b20gKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vLyBjb2RlIGZyb20gc3RpcHNhbi9jb21wdXRlLXNjcm9sbC1pbnRvLXZpZXdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGlwc2FuL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldy9ibG9iLzUzOTZjNmI3OGFmNWQwYmJjZTExYTdjNGU5M2NjMzE0NjU0NmZjZDMvc3JjL2luZGV4LnRzXG4vKipcbiAqIEZpbmQgb3V0IHdoaWNoIGVkZ2UgdG8gYWxpZ24gYWdhaW5zdCB3aGVuIGxvZ2ljYWwgc2Nyb2xsIHBvc2l0aW9uIGlzIFwibmVhcmVzdFwiXG4gKiBJbnRlcmVzdGluZyBmYWN0OiBcIm5lYXJlc3RcIiB3b3JrcyBzaW1pbGFyaWx5IHRvIFwiaWYtbmVlZGVkXCIsIGlmIHRoZSBlbGVtZW50IGlzIGZ1bGx5IHZpc2libGUgaXQgd2lsbCBub3Qgc2Nyb2xsIGl0XG4gKlxuICogTGVnZW5kczpcbiAqIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilI8g4pSBIOKUgSDilIEg4pSTXG4gKiDilIIgdGFyZ2V0IOKUgiAgIGZyYW1lXG4gKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilJgg4pSXIOKUgSDilIEg4pSBIOKUm1xuICovXG5jb25zdCBtYXBOZWFyZXN0ID0gKGFsaWduLCBzY3JvbGxpbmdFZGdlU3RhcnQsIHNjcm9sbGluZ0VkZ2VFbmQsIHNjcm9sbGluZ1NpemUsIGVsZW1lbnRFZGdlU3RhcnQsIGVsZW1lbnRFZGdlRW5kLCBlbGVtZW50U2l6ZSkgPT4ge1xuICAgIGlmIChhbGlnbiAhPT0gMCAvKiBUb0VkZ2VJZk5lZWRlZCAqLykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGFuZCBlbGVtZW50IGVkZ2UgQiBhcmUgYm90aCBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBBIGFuZCBzY3JvbGxpbmcgYm94IGVkZ2UgQlxuICAgICAqXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICogICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUk1xuICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUgyDilIIgIOKUgiDilIMgICAgICAgIGRvIG5vdGhpbmdcbiAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIHilILilIHilIHilILilIHilJtcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKlxuICAgICAqICBJZiBlbGVtZW50IGVkZ2UgQyBhbmQgZWxlbWVudCBlZGdlIEQgYXJlIGJvdGggb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQyBhbmQgc2Nyb2xsaW5nIGJveCBlZGdlIERcbiAgICAgKlxuICAgICAqICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgKiAgIOKUguKUgyAgICAgICAgIOKUg+KUgiAgICAgICAgZG8gbm90aGluZ1xuICAgICAqICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICogICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKi9cbiAgICBpZiAoKGVsZW1lbnRFZGdlU3RhcnQgPCBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPiBzY3JvbGxpbmdFZGdlRW5kKSB8fFxuICAgICAgICAoZWxlbWVudEVkZ2VTdGFydCA+IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50RWRnZUVuZCA8IHNjcm9sbGluZ0VkZ2VFbmQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQSBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBBIGFuZCBlbGVtZW50IGhlaWdodCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgKlxuICAgICAqICAgICAgICAgIOKUjOKUgOKUgOKUkFxuICAgICAqICAgICAgICDilI/ilIHilILilIHilIHilILilIHilJMgICAgICAgICDilI/ilIHilIzilIHilIHilJDilIHilJNcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJggICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgZnJvbSAg4pSDICAgICAg4pSDICAgICB0byAg4pSDIOKUlOKUgOKUgOKUmCDilINcbiAgICAgKlxuICAgICAqICAgICAgICDilJfilIEg4pSB4pSBIOKUgeKUmyAgICAgICAgIOKUl+KUgSDilIHilIEg4pSB4pSbXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQiBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBCIGFuZCBlbGVtZW50IGhlaWdodCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgKlxuICAgICAqICAgICAgICDilI/ilIEg4pSB4pSBIOKUgeKUkyAgICAgICAgIOKUj+KUgeKUjOKUgeKUgeKUkOKUgeKUk1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgZnJvbSAg4pSDIOKUjOKUgOKUgOKUkCDilIMgICAgIHRvICDilIMg4pSCICDilIIg4pSDXG4gICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbICAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbXG4gICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSU4pSA4pSA4pSYXG4gICAgICogICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBDIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEMgYW5kIGVsZW1lbnQgd2lkdGggaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgKlxuICAgICAqICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJMgICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICDilIzilIDilIDilIDilJAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxuICAgICAqICDilIIg4pSDIOKUgiAgICAgICDilIMgICAgICAgICDilIMgICDilIIgICAgIOKUg1xuICAgICAqICDilJTilIDilIDilIDilJggICAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmFxuICAgICAqICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBEIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEQgYW5kIGVsZW1lbnQgd2lkdGggaXMgZ3JlYXRlciB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgKlxuICAgICAqICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJMgICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgKiAgICDilIMgICDilIIgICAgIOKUgyAgICAg4pSCICAg4pSDICAgICAgICAg4pSDIOKUglxuICAgICAqICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAgKiAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUmyAgICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICovXG4gICAgaWYgKChlbGVtZW50RWRnZVN0YXJ0IDw9IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50U2l6ZSA8PSBzY3JvbGxpbmdTaXplKSB8fFxuICAgICAgICAoZWxlbWVudEVkZ2VFbmQgPj0gc2Nyb2xsaW5nRWRnZUVuZCAmJiBlbGVtZW50U2l6ZSA+PSBzY3JvbGxpbmdTaXplKSkge1xuICAgICAgICByZXR1cm4gMiAvKiBMZWZ0T3JUb3AgKi87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBCIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEIgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgIOKUj+KUgSDilIHilIEg4pSB4pSTICAgICAgICAg4pSP4pSBIOKUgeKUgSDilIHilJNcbiAgICAgKlxuICAgICAqICBmcm9tICDilIMgICAgICDilIMgICAgIHRvICDilIMg4pSM4pSA4pSA4pSQIOKUg1xuICAgICAqICAgICAgICAgIOKUjOKUgOKUgOKUkCAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIHilILilIHilIHilILilIHilJsgICAgICAgICDilJfilIHilJTilIHilIHilJjilIHilJtcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEEgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICogICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgKiAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTICAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTXG4gICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgZnJvbSAg4pSDIOKUlOKUgOKUgOKUmCDilIMgICAgIHRvICDilIMg4pSCICDilIIg4pSDXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIEg4pSB4pSBIOKUgeKUmyAgICAgICAgIOKUl+KUgeKUlOKUgeKUgeKUmOKUgeKUm1xuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEMgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQyBhbmQgZWxlbWVudCB3aWR0aCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgKiAg4pSCICAgICDilIMgICAgIOKUgiAgIOKUgyAgICAgICDilIIg4pSDICAgICAgICAg4pSDXG4gICAgICogIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICogICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBEIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEQgYW5kIGVsZW1lbnQgd2lkdGggaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgKlxuICAgICAqICAgICAgICAgICBmcm9tICAgICAgICAgICAgICAgICB0b1xuICAgICAqICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxuICAgICAqICAgICAgICDilIMgICAgICAg4pSCIOKUgyDilIIgICAgICAg4pSDICAgICDilIIgICDilINcbiAgICAgKiAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJggICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXG4gICAgICogICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKlxuICAgICAqL1xuICAgIGlmICgoZWxlbWVudEVkZ2VFbmQgPiBzY3JvbGxpbmdFZGdlRW5kICYmIGVsZW1lbnRTaXplIDwgc2Nyb2xsaW5nU2l6ZSkgfHxcbiAgICAgICAgKGVsZW1lbnRFZGdlU3RhcnQgPCBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudFNpemUgPiBzY3JvbGxpbmdTaXplKSkge1xuICAgICAgICByZXR1cm4gMyAvKiBSaWdodE9yQm90dG9tICovO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBjYW5PdmVyZmxvdyA9IChvdmVyZmxvdykgPT4ge1xuICAgIHJldHVybiBvdmVyZmxvdyAhPT0gXCJ2aXNpYmxlXCIgJiYgb3ZlcmZsb3cgIT09IFwiY2xpcFwiO1xufTtcbmNvbnN0IGdldEZyYW1lRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoKF9hID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJhbWVFbGVtZW50KSB8fCBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmNvbnN0IGlzU2Nyb2xsYWJsZSA9IChlbGVtZW50LCBjb21wdXRlZFN0eWxlKSA9PiB7XG4gICAgaWYgKGVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgZWxlbWVudC5jbGllbnRXaWR0aCA8IGVsZW1lbnQuc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIChjYW5PdmVyZmxvdyhjb21wdXRlZFN0eWxlLm92ZXJmbG93WSkgfHxcbiAgICAgICAgICAgIGNhbk92ZXJmbG93KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSB8fFxuICAgICAgICAgICAgZWxlbWVudCA9PT0gc2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBwYXJlbnRFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBwTm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBjb25zdCBwRWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAocEVsZW1lbnQgPT09IG51bGwgJiYgcE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHBOb2RlLm5vZGVUeXBlID09PSAvKiogTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICovIDExKSB7XG4gICAgICAgICAgICByZXR1cm4gcE5vZGUuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocE5vZGUubm9kZVR5cGUgPT09IC8qKiBOb2RlLkRPQ1VNRU5UX05PREUgKi8gOSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZyYW1lRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcEVsZW1lbnQ7XG59O1xuY29uc3QgY2xhbXAgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgZ2V0U3VwcG9ydGVkU2Nyb2xsTWFyZ2luUHJvcGVydHkgPSAob3duZXJEb2N1bWVudCkgPT4ge1xuICAgIC8vIFdlYmtpdCB1c2VzIFwic2Nyb2xsLXNuYXAtbWFyZ2luXCIgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4OTI2NS5cbiAgICByZXR1cm4gW1wic2Nyb2xsLW1hcmdpblwiLCBcInNjcm9sbC1zbmFwLW1hcmdpblwiXS5maWx0ZXIoKHByb3BlcnR5KSA9PiBwcm9wZXJ0eSBpbiBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSlbMF07XG59O1xuY29uc3QgZ2V0RWxlbWVudFNjcm9sbFNuYXBBcmVhID0gKGVsZW1lbnQsIGVsZW1lbnRSZWN0LCBjb21wdXRlZFN0eWxlKSA9PiB7XG4gICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IGVsZW1lbnRSZWN0O1xuICAgIGNvbnN0IHNjcm9sbFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkU2Nyb2xsTWFyZ2luUHJvcGVydHkoZWxlbWVudC5vd25lckRvY3VtZW50KTtcbiAgICBpZiAoIXNjcm9sbFByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XTtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsTWFyZ2luVmFsdWUgPSAoZWRnZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShgJHtzY3JvbGxQcm9wZXJ0eX0tJHtlZGdlfWApO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKSB8fCAwO1xuICAgIH07XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdG9wIC0gc2Nyb2xsTWFyZ2luVmFsdWUoXCJ0b3BcIiksXG4gICAgICAgIHJpZ2h0ICsgc2Nyb2xsTWFyZ2luVmFsdWUoXCJyaWdodFwiKSxcbiAgICAgICAgYm90dG9tICsgc2Nyb2xsTWFyZ2luVmFsdWUoXCJib3R0b21cIiksXG4gICAgICAgIGxlZnQgLSBzY3JvbGxNYXJnaW5WYWx1ZShcImxlZnRcIiksXG4gICAgXTtcbn07XG5jb25zdCBjYWxjQWxpZ25FZGdlID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiB7XG4gICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIDEgLyogQ2VudGVyQWx3YXlzICovOlxuICAgICAgICAgICAgcmV0dXJuIChzdGFydCArIGVuZCkgLyAyO1xuICAgICAgICBjYXNlIDMgLyogUmlnaHRPckJvdHRvbSAqLzpcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGNhc2UgMiAvKiBMZWZ0T3JUb3AgKi86XG4gICAgICAgIGNhc2UgMCAvKiBUb0VkZ2VJZk5lZWRlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG59O1xuY29uc3QgZ2V0RnJhbWVWaWV3cG9ydCA9IChmcmFtZSwgZnJhbWVSZWN0KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSAoX2EgPSBmcmFtZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlzdWFsVmlld3BvcnQ7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZnJhbWUgPT09IHNjcm9sbGluZ0VsZW1lbnQoZnJhbWUpXG4gICAgICAgID8gWzAsIDAsIChfYiA9IHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8IHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxWaWV3cG9ydC53aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnJhbWUuY2xpZW50V2lkdGgsIChfYyA9IHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8IHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxWaWV3cG9ydC5oZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZyYW1lLmNsaWVudEhlaWdodF1cbiAgICAgICAgOiBbZnJhbWVSZWN0LmxlZnQsIGZyYW1lUmVjdC50b3AsIGZyYW1lLmNsaWVudFdpZHRoLCBmcmFtZS5jbGllbnRIZWlnaHRdO1xuICAgIGNvbnN0IGxlZnQgPSB4ICsgZnJhbWUuY2xpZW50TGVmdDtcbiAgICBjb25zdCB0b3AgPSB5ICsgZnJhbWUuY2xpZW50VG9wO1xuICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF07XG59O1xuY29uc3QgY29tcHV0ZVNjcm9sbEludG9WaWV3ID0gKGVsZW1lbnQsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBDb2xsZWN0IGFsbCB0aGUgc2Nyb2xsaW5nIGJveGVzLCBhcyBkZWZpbmVkIGluIHRoZSBzcGVjOiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20tdmlldy8jc2Nyb2xsaW5nLWJveFxuICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICBsZXQgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBsZXQgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGlmICghb3duZXJXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBjb25zdCBpc0xUUiA9IGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uICE9PSBcInJ0bFwiO1xuICAgIGNvbnN0IHdyaXRpbmdNb2RlID0gbm9ybWFsaXplV3JpdGluZ01vZGUoY29tcHV0ZWRTdHlsZS53cml0aW5nTW9kZSB8fFxuICAgICAgICBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItd2Via2l0LXdyaXRpbmctbW9kZVwiKSB8fFxuICAgICAgICBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItbXMtd3JpdGluZy1tb2RlXCIpKTtcbiAgICBjb25zdCBbYWxpZ25ILCBhbGlnblZdID0gdG9QaHlzaWNhbEFsaWdubWVudChvcHRpb25zLCB3cml0aW5nTW9kZSwgaXNMVFIpO1xuICAgIGxldCBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XSA9IGdldEVsZW1lbnRTY3JvbGxTbmFwQXJlYShlbGVtZW50LCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBjb21wdXRlZFN0eWxlKTtcbiAgICBmb3IgKGxldCBmcmFtZSA9IHBhcmVudEVsZW1lbnQoZWxlbWVudCk7IGZyYW1lICE9PSBudWxsOyBmcmFtZSA9IHBhcmVudEVsZW1lbnQoZnJhbWUpKSB7XG4gICAgICAgIGlmIChvd25lckRvY3VtZW50ICE9PSBmcmFtZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICBvd25lckRvY3VtZW50ID0gZnJhbWUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIGlmICghb3duZXJXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbGVmdDogZFgsIHRvcDogZFkgfSA9IGZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdG9wICs9IGRZO1xuICAgICAgICAgICAgcmlnaHQgKz0gZFg7XG4gICAgICAgICAgICBib3R0b20gKz0gZFk7XG4gICAgICAgICAgICBsZWZ0ICs9IGRYO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGZyYW1lKTtcbiAgICAgICAgaWYgKGZyYW1lU3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1Njcm9sbGFibGUoZnJhbWUsIGZyYW1lU3R5bGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZVJlY3QgPSBmcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgW2ZyYW1lVG9wLCBmcmFtZVJpZ2h0LCBmcmFtZUJvdHRvbSwgZnJhbWVMZWZ0XSA9IGdldEZyYW1lVmlld3BvcnQoZnJhbWUsIGZyYW1lUmVjdCk7XG4gICAgICAgIGNvbnN0IGVBbGlnbkggPSBtYXBOZWFyZXN0KGFsaWduSCwgZnJhbWVMZWZ0LCBmcmFtZVJpZ2h0LCBmcmFtZS5jbGllbnRXaWR0aCwgbGVmdCwgcmlnaHQsIHJpZ2h0IC0gbGVmdCk7XG4gICAgICAgIGNvbnN0IGVBbGlnblYgPSBtYXBOZWFyZXN0KGFsaWduViwgZnJhbWVUb3AsIGZyYW1lQm90dG9tLCBmcmFtZS5jbGllbnRIZWlnaHQsIHRvcCwgYm90dG9tLCBib3R0b20gLSB0b3ApO1xuICAgICAgICBjb25zdCBkaWZmWCA9IGVBbGlnbkggPT09IG51bGwgPyAwIDogY2FsY0FsaWduRWRnZShlQWxpZ25ILCBsZWZ0LCByaWdodCkgLSBjYWxjQWxpZ25FZGdlKGVBbGlnbkgsIGZyYW1lTGVmdCwgZnJhbWVSaWdodCk7XG4gICAgICAgIGNvbnN0IGRpZmZZID0gZUFsaWduViA9PT0gbnVsbCA/IDAgOiBjYWxjQWxpZ25FZGdlKGVBbGlnblYsIHRvcCwgYm90dG9tKSAtIGNhbGNBbGlnbkVkZ2UoZUFsaWduViwgZnJhbWVUb3AsIGZyYW1lQm90dG9tKTtcbiAgICAgICAgY29uc3QgbW92ZVggPSBpc1hSZXZlcnNlZChmcmFtZVN0eWxlKVxuICAgICAgICAgICAgPyBjbGFtcChkaWZmWCwgLWZyYW1lLnNjcm9sbFdpZHRoICsgZnJhbWUuY2xpZW50V2lkdGggLSBmcmFtZS5zY3JvbGxMZWZ0LCAtZnJhbWUuc2Nyb2xsTGVmdClcbiAgICAgICAgICAgIDogY2xhbXAoZGlmZlgsIC1mcmFtZS5zY3JvbGxMZWZ0LCBmcmFtZS5zY3JvbGxXaWR0aCAtIGZyYW1lLmNsaWVudFdpZHRoIC0gZnJhbWUuc2Nyb2xsTGVmdCk7XG4gICAgICAgIGNvbnN0IG1vdmVZID0gY2xhbXAoZGlmZlksIC1mcmFtZS5zY3JvbGxUb3AsIGZyYW1lLnNjcm9sbEhlaWdodCAtIGZyYW1lLmNsaWVudEhlaWdodCAtIGZyYW1lLnNjcm9sbFRvcCk7XG4gICAgICAgIGFjdGlvbnMucHVzaChbXG4gICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgIHsgbGVmdDogZnJhbWUuc2Nyb2xsTGVmdCArIG1vdmVYLCB0b3A6IGZyYW1lLnNjcm9sbFRvcCArIG1vdmVZLCBiZWhhdmlvcjogb3B0aW9ucy5iZWhhdmlvciB9LFxuICAgICAgICBdKTtcbiAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wIC0gbW92ZVksIGZyYW1lVG9wKTtcbiAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCAtIG1vdmVYLCBmcmFtZVJpZ2h0KTtcbiAgICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tIC0gbW92ZVksIGZyYW1lQm90dG9tKTtcbiAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQgLSBtb3ZlWCwgZnJhbWVMZWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbnM7XG59O1xuZXhwb3J0IGNvbnN0IHNjcm9sbEludG9WaWV3ID0gKGVsZW1lbnQsIHNjcm9sbEludG9WaWV3T3B0aW9ucywgY29uZmlnKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIWNoZWNrQmVoYXZpb3Iob3B0aW9ucy5iZWhhdmlvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZShcInNjcm9sbEludG9WaWV3XCIsIFwiRWxlbWVudFwiLCBvcHRpb25zLmJlaGF2aW9yKSk7XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbnMgPSBjb21wdXRlU2Nyb2xsSW50b1ZpZXcoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgYWN0aW9ucy5mb3JFYWNoKChbZnJhbWUsIHNjcm9sbFRvT3B0aW9uc10pID0+IHtcbiAgICAgICAgZWxlbWVudFNjcm9sbChmcmFtZSwgc2Nyb2xsVG9PcHRpb25zLCBjb25maWcpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbEludG9WaWV3LmpzLm1hcCIsImltcG9ydCB7IGVsZW1lbnRTY3JvbGxJbnRvVmlldyB9IGZyb20gJ3NlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbCc7XHJcblxyXG5jb25zdCBzY3JvbGxJbnRvVmlldyA9ICgpID0+IHtcclxuXHRjb25zdCBoZWFkZXJNZW51ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlci1tZW51Jyk7XHJcblxyXG5cdGNvbnN0IHNjcm9sbFVwID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG5cdFx0ZWxlbWVudFNjcm9sbEludG9WaWV3KG9iamVjdCwgeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJywgaW5saW5lOiAnY2VudGVyJyB9KTtcclxuXHR9O1xyXG5cclxuXHRoZWFkZXJNZW51LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuXHRcdGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2hlYWRlci1tZW51LWl0ZW0nKSkge1xyXG5cdFx0XHRjb25zdCBpdGVtTGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpLnN1YnN0cmluZygxKSk7XHJcblx0XHRcdHNjcm9sbFVwLmJpbmQoaXRlbUxpbmspKGl0ZW1MaW5rKTtcclxuXHRcdH1cclxuXHR9KTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNjcm9sbEludG9WaWV3O1xyXG4iLCJjb25zdCBjaGFuZ2VUaGVtZSA9ICgpID0+IHtcclxuXHRjb25zdCBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhbmdlLXRoZW1lLWJ1dHRvbicpO1xyXG5cclxuXHRjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xyXG5cdGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXInKTtcclxuXHRjb25zdCBoZWFkZXJNZW51VGhlbWVCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaGVhZGVyLW1lbnUtdGhlbWUtYnV0dG9uJyk7XHJcblx0Y29uc3QgaTJTa2lsbHNJdGVtQm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmkyLXNraWxscy1pdGVtLWJveCcpO1xyXG5cdGNvbnN0IGZvb3RlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb290ZXInKTtcclxuXHRjb25zdCBpdGVtMSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pMScpO1xyXG5cdGNvbnN0IGl0ZW0yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmkyJyk7XHJcblx0Y29uc3QgaXRlbTMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaTMnKTtcclxuXHRjb25zdCBpdGVtNCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pNCcpO1xyXG5cdGNvbnN0IGl0ZW01ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmk1Jyk7XHJcblx0Y29uc3QgaXRlbTYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaTYnKTtcclxuXHRjb25zdCBhcnJheSA9IFtib2R5LCBoZWFkZXIsIGhlYWRlck1lbnVUaGVtZUJ1dHRvbiwgaTJTa2lsbHNJdGVtQm94LCBmb290ZXIsIGl0ZW0xLCBpdGVtMiwgaXRlbTMsIGl0ZW00LCBpdGVtNSwgaXRlbTZdO1xyXG5cclxuXHRjb25zdCB0b2dnbGVUaGVtZSA9ICgpID0+IHtcclxuXHRcdGFycmF5LmZvckVhY2goKGl0ZW0pID0+IHtcclxuXHRcdFx0aXRlbS5jbGFzc0xpc3QudG9nZ2xlKCdkYXJrLW1vZGUnKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdHRvZ2dsZVRoZW1lKCk7XHJcblx0XHRpZiAoYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ2RhcmstbW9kZScpKSB7XHJcblx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdpc0RhcmtNb2RlJywgdHJ1ZSk7XHJcblx0XHRcdGJ1dHRvbi50ZXh0Q29udGVudCA9ICfQodCy0LXRgtC70YvQuSDRgNC10LbQuNC8JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGJ1dHRvbi50ZXh0Q29udGVudCA9ICfQotGR0LzQvdGL0Lkg0YDQtdC20LjQvCc7XHJcblx0XHRcdGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdpc0RhcmtNb2RlJywgZmFsc2UpO1xyXG5cdFx0fVxyXG5cdFx0aXNEYXJrTW9kZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdpc0RhcmtNb2RlJyk7XHJcblx0XHRjb25zb2xlLmxvZygnfiBpc0RhcmtNb2RlJywgaXNEYXJrTW9kZSk7XHJcblx0fSk7XHJcblxyXG5cdGxldCBpc0RhcmtNb2RlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2lzRGFya01vZGUnKTtcclxuXHRjb25zb2xlLmxvZygnfiBpc0RhcmtNb2RlJywgaXNEYXJrTW9kZSk7XHJcblxyXG5cdGlmIChpc0RhcmtNb2RlID09PSAndHJ1ZScpIHtcclxuXHRcdHRvZ2dsZVRoZW1lKCk7XHJcblx0XHRidXR0b24udGV4dENvbnRlbnQgPSAn0KHQstC10YLQu9GL0Lkg0YDQtdC20LjQvCc7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2hhbmdlVGhlbWU7XHJcbiIsImNvbnN0IGFuaW1hdGUgPSBmdW5jdGlvbiAoeyB0aW1pbmcsIGRyYXcsIGR1cmF0aW9uIH0pIHtcclxuXHRsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGUodGltZSkge1xyXG5cdFx0Ly8gdGltZUZyYWN0aW9uINC40LfQvNC10L3Rj9C10YLRgdGPINC+0YIgMCDQtNC+IDFcclxuXHRcdGxldCB0aW1lRnJhY3Rpb24gPSAodGltZSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xyXG5cdFx0aWYgKHRpbWVGcmFjdGlvbiA+IDEpIHRpbWVGcmFjdGlvbiA9IDE7XHJcblxyXG5cdFx0Ly8g0LLRi9GH0LjRgdC70LXQvdC40LUg0YLQtdC60YPRidC10LPQviDRgdC+0YHRgtC+0Y/QvdC40Y8g0LDQvdC40LzQsNGG0LjQuFxyXG5cdFx0bGV0IHByb2dyZXNzID0gdGltaW5nKHRpbWVGcmFjdGlvbik7XHJcblxyXG5cdFx0ZHJhdyhwcm9ncmVzcyk7IC8vINC+0YLRgNC40YHQvtCy0LDRgtGMINC10ZFcclxuXHJcblx0XHRpZiAodGltZUZyYWN0aW9uIDwgMSkge1xyXG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxyXG5leHBvcnQgeyBhbmltYXRlIH07XHJcbiIsImltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuY29uc3Qgc3RpY2tNZW51ID0gKCkgPT4ge1xyXG5cdGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXInKTtcclxuXHRsZXQgbGFzdFNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuXHJcblx0Y29uc3QgbWVudUFuaW1hdGUgPSAodGltZSkgPT4ge1xyXG5cdFx0YW5pbWF0ZSh7XHJcblx0XHRcdGR1cmF0aW9uOiB0aW1lLFxyXG5cdFx0XHR0aW1pbmcodGltZUZyYWN0aW9uKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRpbWVGcmFjdGlvbjtcclxuXHRcdFx0fSxcclxuXHRcdFx0ZHJhdyhwcm9ncmVzcykge1xyXG5cdFx0XHRcdGhlYWRlci5zdHlsZS50b3AgPSBgJHstNjAgKyBwcm9ncmVzcyAqIDYwfXB4YDtcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PiB7XHJcblx0XHRpZiAod2luZG93LnBhZ2VZT2Zmc2V0IDwgbGFzdFNjcm9sbFRvcCkge1xyXG5cdFx0XHRpZiAoaGVhZGVyLnN0eWxlLnRvcCAhPSAnMHB4JyAmJiBoZWFkZXIuc3R5bGUudG9wLnN1YnN0cigwLCAxKSAhPT0gJy0nKSB7XHJcblx0XHRcdFx0bWVudUFuaW1hdGUoMTAwMCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWRlci5zdHlsZS50b3AgPSAnJztcclxuXHRcdH1cclxuXHRcdGxhc3RTY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzdGlja01lbnU7XHJcbiIsImltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5cclxuY29uc3Qgc2tpbGxzQW5pbWF0aW9uID0gKHNraWxsc0FycmF5LCB0aW1lKSA9PiB7XHJcblx0Y29uc3Qgc2tpbGxJdGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pMi1za2lsbHMtaXRlbScpO1xyXG5cdGNvbnN0IHNraWxsc0Jsb2NrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NraWxscycpO1xyXG5cdGxldCBpbmRleCA9IDA7XHJcblx0bGV0IGlzU2tpbGxzQW5pbWF0aW9uU2hvd24gPSBmYWxzZTtcclxuXHJcblx0Y29uc3QgZ2V0SXRlbVRleHQgPSAoaW5kZXgpID0+IHtcclxuXHRcdHNraWxsSXRlbXNbaW5kZXhdLnF1ZXJ5U2VsZWN0b3IoJy5za2lsbC12YWx1ZScpLnRleHRDb250ZW50ID0gc2tpbGxzQXJyYXlbaW5kZXhdLnZhbHVlICsgJyUnO1xyXG5cdFx0c2tpbGxJdGVtc1tpbmRleF0ucXVlcnlTZWxlY3RvcignLnNraWxsLW5hbWUnKS50ZXh0Q29udGVudCA9IHNraWxsc0FycmF5W2luZGV4XS5za2lsbDtcclxuXHRcdGluZGV4Kys7XHJcblx0XHRpZiAoaW5kZXggPCBza2lsbEl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0XHRhbmltYXRlSXRlbShpbmRleCwgdGltZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRjb25zdCBhbmltYXRlSXRlbSA9IChpbmRleCwgdGltZSkgPT4ge1xyXG5cdFx0c2tpbGxJdGVtc1tpbmRleF0uc3R5bGUub3BhY2l0eSA9ICcxJztcclxuXHRcdGFuaW1hdGUoe1xyXG5cdFx0XHRkdXJhdGlvbjogKHRpbWUgKiBza2lsbHNBcnJheVtpbmRleF0udmFsdWUpIC8gMzAsXHJcblx0XHRcdHRpbWluZyh0aW1lRnJhY3Rpb24pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGltZUZyYWN0aW9uO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRkcmF3KHByb2dyZXNzKSB7XHJcblx0XHRcdFx0c2tpbGxJdGVtc1tpbmRleF0ucXVlcnlTZWxlY3RvcignLnNraWxsLW5hbWUnKS5zdHlsZS53aWR0aCA9IGAke3Byb2dyZXNzICogc2tpbGxzQXJyYXlbaW5kZXhdLnZhbHVlfSVgO1xyXG5cdFx0XHRcdGlmIChwcm9ncmVzcyA+PSAxKSB7XHJcblx0XHRcdFx0XHRnZXRJdGVtVGV4dChpbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcclxuXHRcdGNvbnN0IGJsb2NrWSA9IHNraWxsc0Jsb2NrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcclxuXHRcdGNvbnN0IHBhZ2VZID0gd2luZG93LnBhZ2VZT2Zmc2V0ICsgc2tpbGxzQmxvY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG5cclxuXHRcdGlmIChibG9ja1kgPCBwYWdlWSAmJiAhaXNTa2lsbHNBbmltYXRpb25TaG93bikge1xyXG5cdFx0XHRpc1NraWxsc0FuaW1hdGlvblNob3duID0gdHJ1ZTtcclxuXHRcdFx0YW5pbWF0ZUl0ZW0oaW5kZXgsIHRpbWUpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBza2lsbHNBbmltYXRpb247XHJcbiIsImltcG9ydCBjaG9vc2VBYm91dCBmcm9tICcuL21vZHVsZXMvY2hvb3NlQWJvdXQnO1xyXG5pbXBvcnQgc2Nyb2xsSW50b1ZpZXcgZnJvbSAnLi9tb2R1bGVzL3Njcm9sbEludG9WaWV3JztcclxuaW1wb3J0IGNoYW5nZVRoZW1lIGZyb20gJy4vbW9kdWxlcy9jaGFuZ2VUaGVtZSc7XHJcbmltcG9ydCBzdGlja01lbnUgZnJvbSAnLi9tb2R1bGVzL3N0aWNrTWVudSc7XHJcbmltcG9ydCBza2lsbHNBbmltYXRpb24gZnJvbSAnLi9tb2R1bGVzL3NraWxsc0FuaW1hdGlvbic7XHJcblxyXG5jaG9vc2VBYm91dCgpO1xyXG5zY3JvbGxJbnRvVmlldygpO1xyXG5jaGFuZ2VUaGVtZSgpO1xyXG5zdGlja01lbnUoKTtcclxuc2tpbGxzQW5pbWF0aW9uKFxyXG5cdFtcclxuXHRcdHtcclxuXHRcdFx0c2tpbGw6ICdIVE1MICYgQ1NTJyxcclxuXHRcdFx0dmFsdWU6IDUwLFxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2tpbGw6ICdKQVZBU0NSSVBUJyxcclxuXHRcdFx0dmFsdWU6IDgwLFxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2tpbGw6ICdHSVQnLFxyXG5cdFx0XHR2YWx1ZTogNDAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ1dFQlBBQ0snLFxyXG5cdFx0XHR2YWx1ZTogNDAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ1NDU1MvU0FTUycsXHJcblx0XHRcdHZhbHVlOiAzMCxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNraWxsOiAnQk9PVFNUUkFQJyxcclxuXHRcdFx0dmFsdWU6IDIwLFxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2tpbGw6ICdHVUxQJyxcclxuXHRcdFx0dmFsdWU6IDMwLFxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2tpbGw6ICdQVUcnLFxyXG5cdFx0XHR2YWx1ZTogMTAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ1BIT1RPU0hPUCcsXHJcblx0XHRcdHZhbHVlOiA4MCxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNraWxsOiAnRklHTUEnLFxyXG5cdFx0XHR2YWx1ZTogMjAsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRza2lsbDogJ1JFQUNUJyxcclxuXHRcdFx0dmFsdWU6IDEwLFxyXG5cdFx0fSxcclxuXHRdLFxyXG5cdDE1MFxyXG4pO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89\n")}},__webpack_exports__={};__webpack_modules__[89]()})();